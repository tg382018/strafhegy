"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@vue+compiler-dom@3.5.22";
exports.ids = ["vendor-chunks/@vue+compiler-dom@3.5.22"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/@vue+compiler-dom@3.5.22/node_modules/@vue/compiler-dom/dist/compiler-dom.cjs.js":
/*!*****************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@vue+compiler-dom@3.5.22/node_modules/@vue/compiler-dom/dist/compiler-dom.cjs.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n* @vue/compiler-dom v3.5.22\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**/\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar compilerCore = __webpack_require__(/*! @vue/compiler-core */ \"(ssr)/../../node_modules/.pnpm/@vue+compiler-core@3.5.22/node_modules/@vue/compiler-core/dist/compiler-core.cjs.js\");\nvar shared = __webpack_require__(/*! @vue/shared */ \"(ssr)/../../node_modules/.pnpm/@vue+shared@3.5.22/node_modules/@vue/shared/dist/shared.cjs.js\");\n\nconst V_MODEL_RADIO = Symbol(`vModelRadio` );\nconst V_MODEL_CHECKBOX = Symbol(\n  `vModelCheckbox` \n);\nconst V_MODEL_TEXT = Symbol(`vModelText` );\nconst V_MODEL_SELECT = Symbol(\n  `vModelSelect` \n);\nconst V_MODEL_DYNAMIC = Symbol(\n  `vModelDynamic` \n);\nconst V_ON_WITH_MODIFIERS = Symbol(\n  `vOnModifiersGuard` \n);\nconst V_ON_WITH_KEYS = Symbol(\n  `vOnKeysGuard` \n);\nconst V_SHOW = Symbol(`vShow` );\nconst TRANSITION = Symbol(`Transition` );\nconst TRANSITION_GROUP = Symbol(\n  `TransitionGroup` \n);\ncompilerCore.registerRuntimeHelpers({\n  [V_MODEL_RADIO]: `vModelRadio`,\n  [V_MODEL_CHECKBOX]: `vModelCheckbox`,\n  [V_MODEL_TEXT]: `vModelText`,\n  [V_MODEL_SELECT]: `vModelSelect`,\n  [V_MODEL_DYNAMIC]: `vModelDynamic`,\n  [V_ON_WITH_MODIFIERS]: `withModifiers`,\n  [V_ON_WITH_KEYS]: `withKeys`,\n  [V_SHOW]: `vShow`,\n  [TRANSITION]: `Transition`,\n  [TRANSITION_GROUP]: `TransitionGroup`\n});\n\nconst parserOptions = {\n  parseMode: \"html\",\n  isVoidTag: shared.isVoidTag,\n  isNativeTag: (tag) => shared.isHTMLTag(tag) || shared.isSVGTag(tag) || shared.isMathMLTag(tag),\n  isPreTag: (tag) => tag === \"pre\",\n  isIgnoreNewlineTag: (tag) => tag === \"pre\" || tag === \"textarea\",\n  decodeEntities: void 0,\n  isBuiltInComponent: (tag) => {\n    if (tag === \"Transition\" || tag === \"transition\") {\n      return TRANSITION;\n    } else if (tag === \"TransitionGroup\" || tag === \"transition-group\") {\n      return TRANSITION_GROUP;\n    }\n  },\n  // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher\n  getNamespace(tag, parent, rootNamespace) {\n    let ns = parent ? parent.ns : rootNamespace;\n    if (parent && ns === 2) {\n      if (parent.tag === \"annotation-xml\") {\n        if (tag === \"svg\") {\n          return 1;\n        }\n        if (parent.props.some(\n          (a) => a.type === 6 && a.name === \"encoding\" && a.value != null && (a.value.content === \"text/html\" || a.value.content === \"application/xhtml+xml\")\n        )) {\n          ns = 0;\n        }\n      } else if (/^m(?:[ions]|text)$/.test(parent.tag) && tag !== \"mglyph\" && tag !== \"malignmark\") {\n        ns = 0;\n      }\n    } else if (parent && ns === 1) {\n      if (parent.tag === \"foreignObject\" || parent.tag === \"desc\" || parent.tag === \"title\") {\n        ns = 0;\n      }\n    }\n    if (ns === 0) {\n      if (tag === \"svg\") {\n        return 1;\n      }\n      if (tag === \"math\") {\n        return 2;\n      }\n    }\n    return ns;\n  }\n};\n\nconst transformStyle = (node) => {\n  if (node.type === 1) {\n    node.props.forEach((p, i) => {\n      if (p.type === 6 && p.name === \"style\" && p.value) {\n        node.props[i] = {\n          type: 7,\n          name: `bind`,\n          arg: compilerCore.createSimpleExpression(`style`, true, p.loc),\n          exp: parseInlineCSS(p.value.content, p.loc),\n          modifiers: [],\n          loc: p.loc\n        };\n      }\n    });\n  }\n};\nconst parseInlineCSS = (cssText, loc) => {\n  const normalized = shared.parseStringStyle(cssText);\n  return compilerCore.createSimpleExpression(\n    JSON.stringify(normalized),\n    false,\n    loc,\n    3\n  );\n};\n\nfunction createDOMCompilerError(code, loc) {\n  return compilerCore.createCompilerError(\n    code,\n    loc,\n    DOMErrorMessages \n  );\n}\nconst DOMErrorCodes = {\n  \"X_V_HTML_NO_EXPRESSION\": 53,\n  \"53\": \"X_V_HTML_NO_EXPRESSION\",\n  \"X_V_HTML_WITH_CHILDREN\": 54,\n  \"54\": \"X_V_HTML_WITH_CHILDREN\",\n  \"X_V_TEXT_NO_EXPRESSION\": 55,\n  \"55\": \"X_V_TEXT_NO_EXPRESSION\",\n  \"X_V_TEXT_WITH_CHILDREN\": 56,\n  \"56\": \"X_V_TEXT_WITH_CHILDREN\",\n  \"X_V_MODEL_ON_INVALID_ELEMENT\": 57,\n  \"57\": \"X_V_MODEL_ON_INVALID_ELEMENT\",\n  \"X_V_MODEL_ARG_ON_ELEMENT\": 58,\n  \"58\": \"X_V_MODEL_ARG_ON_ELEMENT\",\n  \"X_V_MODEL_ON_FILE_INPUT_ELEMENT\": 59,\n  \"59\": \"X_V_MODEL_ON_FILE_INPUT_ELEMENT\",\n  \"X_V_MODEL_UNNECESSARY_VALUE\": 60,\n  \"60\": \"X_V_MODEL_UNNECESSARY_VALUE\",\n  \"X_V_SHOW_NO_EXPRESSION\": 61,\n  \"61\": \"X_V_SHOW_NO_EXPRESSION\",\n  \"X_TRANSITION_INVALID_CHILDREN\": 62,\n  \"62\": \"X_TRANSITION_INVALID_CHILDREN\",\n  \"X_IGNORED_SIDE_EFFECT_TAG\": 63,\n  \"63\": \"X_IGNORED_SIDE_EFFECT_TAG\",\n  \"__EXTEND_POINT__\": 64,\n  \"64\": \"__EXTEND_POINT__\"\n};\nconst DOMErrorMessages = {\n  [53]: `v-html is missing expression.`,\n  [54]: `v-html will override element children.`,\n  [55]: `v-text is missing expression.`,\n  [56]: `v-text will override element children.`,\n  [57]: `v-model can only be used on <input>, <textarea> and <select> elements.`,\n  [58]: `v-model argument is not supported on plain elements.`,\n  [59]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,\n  [60]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,\n  [61]: `v-show is missing expression.`,\n  [62]: `<Transition> expects exactly one child element or component.`,\n  [63]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`\n};\n\nconst transformVHtml = (dir, node, context) => {\n  const { exp, loc } = dir;\n  if (!exp) {\n    context.onError(\n      createDOMCompilerError(53, loc)\n    );\n  }\n  if (node.children.length) {\n    context.onError(\n      createDOMCompilerError(54, loc)\n    );\n    node.children.length = 0;\n  }\n  return {\n    props: [\n      compilerCore.createObjectProperty(\n        compilerCore.createSimpleExpression(`innerHTML`, true, loc),\n        exp || compilerCore.createSimpleExpression(\"\", true)\n      )\n    ]\n  };\n};\n\nconst transformVText = (dir, node, context) => {\n  const { exp, loc } = dir;\n  if (!exp) {\n    context.onError(\n      createDOMCompilerError(55, loc)\n    );\n  }\n  if (node.children.length) {\n    context.onError(\n      createDOMCompilerError(56, loc)\n    );\n    node.children.length = 0;\n  }\n  return {\n    props: [\n      compilerCore.createObjectProperty(\n        compilerCore.createSimpleExpression(`textContent`, true),\n        exp ? compilerCore.getConstantType(exp, context) > 0 ? exp : compilerCore.createCallExpression(\n          context.helperString(compilerCore.TO_DISPLAY_STRING),\n          [exp],\n          loc\n        ) : compilerCore.createSimpleExpression(\"\", true)\n      )\n    ]\n  };\n};\n\nconst transformModel = (dir, node, context) => {\n  const baseResult = compilerCore.transformModel(dir, node, context);\n  if (!baseResult.props.length || node.tagType === 1) {\n    return baseResult;\n  }\n  if (dir.arg) {\n    context.onError(\n      createDOMCompilerError(\n        58,\n        dir.arg.loc\n      )\n    );\n  }\n  function checkDuplicatedValue() {\n    const value = compilerCore.findDir(node, \"bind\");\n    if (value && compilerCore.isStaticArgOf(value.arg, \"value\")) {\n      context.onError(\n        createDOMCompilerError(\n          60,\n          value.loc\n        )\n      );\n    }\n  }\n  const { tag } = node;\n  const isCustomElement = context.isCustomElement(tag);\n  if (tag === \"input\" || tag === \"textarea\" || tag === \"select\" || isCustomElement) {\n    let directiveToUse = V_MODEL_TEXT;\n    let isInvalidType = false;\n    if (tag === \"input\" || isCustomElement) {\n      const type = compilerCore.findProp(node, `type`);\n      if (type) {\n        if (type.type === 7) {\n          directiveToUse = V_MODEL_DYNAMIC;\n        } else if (type.value) {\n          switch (type.value.content) {\n            case \"radio\":\n              directiveToUse = V_MODEL_RADIO;\n              break;\n            case \"checkbox\":\n              directiveToUse = V_MODEL_CHECKBOX;\n              break;\n            case \"file\":\n              isInvalidType = true;\n              context.onError(\n                createDOMCompilerError(\n                  59,\n                  dir.loc\n                )\n              );\n              break;\n            default:\n              checkDuplicatedValue();\n              break;\n          }\n        }\n      } else if (compilerCore.hasDynamicKeyVBind(node)) {\n        directiveToUse = V_MODEL_DYNAMIC;\n      } else {\n        checkDuplicatedValue();\n      }\n    } else if (tag === \"select\") {\n      directiveToUse = V_MODEL_SELECT;\n    } else {\n      checkDuplicatedValue();\n    }\n    if (!isInvalidType) {\n      baseResult.needRuntime = context.helper(directiveToUse);\n    }\n  } else {\n    context.onError(\n      createDOMCompilerError(\n        57,\n        dir.loc\n      )\n    );\n  }\n  baseResult.props = baseResult.props.filter(\n    (p) => !(p.key.type === 4 && p.key.content === \"modelValue\")\n  );\n  return baseResult;\n};\n\nconst isEventOptionModifier = /* @__PURE__ */ shared.makeMap(`passive,once,capture`);\nconst isNonKeyModifier = /* @__PURE__ */ shared.makeMap(\n  // event propagation management\n  `stop,prevent,self,ctrl,shift,alt,meta,exact,middle`\n);\nconst maybeKeyModifier = /* @__PURE__ */ shared.makeMap(\"left,right\");\nconst isKeyboardEvent = /* @__PURE__ */ shared.makeMap(`onkeyup,onkeydown,onkeypress`);\nconst resolveModifiers = (key, modifiers, context, loc) => {\n  const keyModifiers = [];\n  const nonKeyModifiers = [];\n  const eventOptionModifiers = [];\n  for (let i = 0; i < modifiers.length; i++) {\n    const modifier = modifiers[i].content;\n    if (modifier === \"native\" && compilerCore.checkCompatEnabled(\n      \"COMPILER_V_ON_NATIVE\",\n      context,\n      loc\n    )) {\n      eventOptionModifiers.push(modifier);\n    } else if (isEventOptionModifier(modifier)) {\n      eventOptionModifiers.push(modifier);\n    } else {\n      if (maybeKeyModifier(modifier)) {\n        if (compilerCore.isStaticExp(key)) {\n          if (isKeyboardEvent(key.content.toLowerCase())) {\n            keyModifiers.push(modifier);\n          } else {\n            nonKeyModifiers.push(modifier);\n          }\n        } else {\n          keyModifiers.push(modifier);\n          nonKeyModifiers.push(modifier);\n        }\n      } else {\n        if (isNonKeyModifier(modifier)) {\n          nonKeyModifiers.push(modifier);\n        } else {\n          keyModifiers.push(modifier);\n        }\n      }\n    }\n  }\n  return {\n    keyModifiers,\n    nonKeyModifiers,\n    eventOptionModifiers\n  };\n};\nconst transformClick = (key, event) => {\n  const isStaticClick = compilerCore.isStaticExp(key) && key.content.toLowerCase() === \"onclick\";\n  return isStaticClick ? compilerCore.createSimpleExpression(event, true) : key.type !== 4 ? compilerCore.createCompoundExpression([\n    `(`,\n    key,\n    `) === \"onClick\" ? \"${event}\" : (`,\n    key,\n    `)`\n  ]) : key;\n};\nconst transformOn = (dir, node, context) => {\n  return compilerCore.transformOn(dir, node, context, (baseResult) => {\n    const { modifiers } = dir;\n    if (!modifiers.length) return baseResult;\n    let { key, value: handlerExp } = baseResult.props[0];\n    const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers, context, dir.loc);\n    if (nonKeyModifiers.includes(\"right\")) {\n      key = transformClick(key, `onContextmenu`);\n    }\n    if (nonKeyModifiers.includes(\"middle\")) {\n      key = transformClick(key, `onMouseup`);\n    }\n    if (nonKeyModifiers.length) {\n      handlerExp = compilerCore.createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [\n        handlerExp,\n        JSON.stringify(nonKeyModifiers)\n      ]);\n    }\n    if (keyModifiers.length && // if event name is dynamic, always wrap with keys guard\n    (!compilerCore.isStaticExp(key) || isKeyboardEvent(key.content.toLowerCase()))) {\n      handlerExp = compilerCore.createCallExpression(context.helper(V_ON_WITH_KEYS), [\n        handlerExp,\n        JSON.stringify(keyModifiers)\n      ]);\n    }\n    if (eventOptionModifiers.length) {\n      const modifierPostfix = eventOptionModifiers.map(shared.capitalize).join(\"\");\n      key = compilerCore.isStaticExp(key) ? compilerCore.createSimpleExpression(`${key.content}${modifierPostfix}`, true) : compilerCore.createCompoundExpression([`(`, key, `) + \"${modifierPostfix}\"`]);\n    }\n    return {\n      props: [compilerCore.createObjectProperty(key, handlerExp)]\n    };\n  });\n};\n\nconst transformShow = (dir, node, context) => {\n  const { exp, loc } = dir;\n  if (!exp) {\n    context.onError(\n      createDOMCompilerError(61, loc)\n    );\n  }\n  return {\n    props: [],\n    needRuntime: context.helper(V_SHOW)\n  };\n};\n\nconst transformTransition = (node, context) => {\n  if (node.type === 1 && node.tagType === 1) {\n    const component = context.isBuiltInComponent(node.tag);\n    if (component === TRANSITION) {\n      return () => {\n        if (!node.children.length) {\n          return;\n        }\n        if (hasMultipleChildren(node)) {\n          context.onError(\n            createDOMCompilerError(\n              62,\n              {\n                start: node.children[0].loc.start,\n                end: node.children[node.children.length - 1].loc.end,\n                source: \"\"\n              }\n            )\n          );\n        }\n        const child = node.children[0];\n        if (child.type === 1) {\n          for (const p of child.props) {\n            if (p.type === 7 && p.name === \"show\") {\n              node.props.push({\n                type: 6,\n                name: \"persisted\",\n                nameLoc: node.loc,\n                value: void 0,\n                loc: node.loc\n              });\n            }\n          }\n        }\n      };\n    }\n  }\n};\nfunction hasMultipleChildren(node) {\n  const children = node.children = node.children.filter(\n    (c) => c.type !== 3 && !(c.type === 2 && !c.content.trim())\n  );\n  const child = children[0];\n  return children.length !== 1 || child.type === 11 || child.type === 9 && child.branches.some(hasMultipleChildren);\n}\n\nconst expReplaceRE = /__VUE_EXP_START__(.*?)__VUE_EXP_END__/g;\nconst stringifyStatic = (children, context, parent) => {\n  if (context.scopes.vSlot > 0) {\n    return;\n  }\n  const isParentCached = parent.type === 1 && parent.codegenNode && parent.codegenNode.type === 13 && parent.codegenNode.children && !shared.isArray(parent.codegenNode.children) && parent.codegenNode.children.type === 20;\n  let nc = 0;\n  let ec = 0;\n  const currentChunk = [];\n  const stringifyCurrentChunk = (currentIndex) => {\n    if (nc >= 20 || ec >= 5) {\n      const staticCall = compilerCore.createCallExpression(context.helper(compilerCore.CREATE_STATIC), [\n        JSON.stringify(\n          currentChunk.map((node) => stringifyNode(node, context)).join(\"\")\n        ).replace(expReplaceRE, `\" + $1 + \"`),\n        // the 2nd argument indicates the number of DOM nodes this static vnode\n        // will insert / hydrate\n        String(currentChunk.length)\n      ]);\n      const deleteCount = currentChunk.length - 1;\n      if (isParentCached) {\n        children.splice(\n          currentIndex - currentChunk.length,\n          currentChunk.length,\n          // @ts-expect-error\n          staticCall\n        );\n      } else {\n        currentChunk[0].codegenNode.value = staticCall;\n        if (currentChunk.length > 1) {\n          children.splice(currentIndex - currentChunk.length + 1, deleteCount);\n          const cacheIndex = context.cached.indexOf(\n            currentChunk[currentChunk.length - 1].codegenNode\n          );\n          if (cacheIndex > -1) {\n            for (let i2 = cacheIndex; i2 < context.cached.length; i2++) {\n              const c = context.cached[i2];\n              if (c) c.index -= deleteCount;\n            }\n            context.cached.splice(cacheIndex - deleteCount + 1, deleteCount);\n          }\n        }\n      }\n      return deleteCount;\n    }\n    return 0;\n  };\n  let i = 0;\n  for (; i < children.length; i++) {\n    const child = children[i];\n    const isCached = isParentCached || getCachedNode(child);\n    if (isCached) {\n      const result = analyzeNode(child);\n      if (result) {\n        nc += result[0];\n        ec += result[1];\n        currentChunk.push(child);\n        continue;\n      }\n    }\n    i -= stringifyCurrentChunk(i);\n    nc = 0;\n    ec = 0;\n    currentChunk.length = 0;\n  }\n  stringifyCurrentChunk(i);\n};\nconst getCachedNode = (node) => {\n  if ((node.type === 1 && node.tagType === 0 || node.type === 12) && node.codegenNode && node.codegenNode.type === 20) {\n    return node.codegenNode;\n  }\n};\nconst dataAriaRE = /^(?:data|aria)-/;\nconst isStringifiableAttr = (name, ns) => {\n  return (ns === 0 ? shared.isKnownHtmlAttr(name) : ns === 1 ? shared.isKnownSvgAttr(name) : ns === 2 ? shared.isKnownMathMLAttr(name) : false) || dataAriaRE.test(name);\n};\nconst isNonStringifiable = /* @__PURE__ */ shared.makeMap(\n  `caption,thead,tr,th,tbody,td,tfoot,colgroup,col`\n);\nfunction analyzeNode(node) {\n  if (node.type === 1 && isNonStringifiable(node.tag)) {\n    return false;\n  }\n  if (node.type === 1 && compilerCore.findDir(node, \"once\", true)) {\n    return false;\n  }\n  if (node.type === 12) {\n    return [1, 0];\n  }\n  let nc = 1;\n  let ec = node.props.length > 0 ? 1 : 0;\n  let bailed = false;\n  const bail = () => {\n    bailed = true;\n    return false;\n  };\n  function walk(node2) {\n    const isOptionTag = node2.tag === \"option\" && node2.ns === 0;\n    for (let i = 0; i < node2.props.length; i++) {\n      const p = node2.props[i];\n      if (p.type === 6 && !isStringifiableAttr(p.name, node2.ns)) {\n        return bail();\n      }\n      if (p.type === 7 && p.name === \"bind\") {\n        if (p.arg && (p.arg.type === 8 || p.arg.isStatic && !isStringifiableAttr(p.arg.content, node2.ns))) {\n          return bail();\n        }\n        if (p.exp && (p.exp.type === 8 || p.exp.constType < 3)) {\n          return bail();\n        }\n        if (isOptionTag && compilerCore.isStaticArgOf(p.arg, \"value\") && p.exp && !p.exp.isStatic) {\n          return bail();\n        }\n      }\n    }\n    for (let i = 0; i < node2.children.length; i++) {\n      nc++;\n      const child = node2.children[i];\n      if (child.type === 1) {\n        if (child.props.length > 0) {\n          ec++;\n        }\n        walk(child);\n        if (bailed) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  return walk(node) ? [nc, ec] : false;\n}\nfunction stringifyNode(node, context) {\n  if (shared.isString(node)) {\n    return node;\n  }\n  if (shared.isSymbol(node)) {\n    return ``;\n  }\n  switch (node.type) {\n    case 1:\n      return stringifyElement(node, context);\n    case 2:\n      return shared.escapeHtml(node.content);\n    case 3:\n      return `<!--${shared.escapeHtml(node.content)}-->`;\n    case 5:\n      return shared.escapeHtml(shared.toDisplayString(evaluateConstant(node.content)));\n    case 8:\n      return shared.escapeHtml(evaluateConstant(node));\n    case 12:\n      return stringifyNode(node.content, context);\n    default:\n      return \"\";\n  }\n}\nfunction stringifyElement(node, context) {\n  let res = `<${node.tag}`;\n  let innerHTML = \"\";\n  for (let i = 0; i < node.props.length; i++) {\n    const p = node.props[i];\n    if (p.type === 6) {\n      res += ` ${p.name}`;\n      if (p.value) {\n        res += `=\"${shared.escapeHtml(p.value.content)}\"`;\n      }\n    } else if (p.type === 7) {\n      if (p.name === \"bind\") {\n        const exp = p.exp;\n        if (exp.content[0] === \"_\") {\n          res += ` ${p.arg.content}=\"__VUE_EXP_START__${exp.content}__VUE_EXP_END__\"`;\n          continue;\n        }\n        if (shared.isBooleanAttr(p.arg.content) && exp.content === \"false\") {\n          continue;\n        }\n        let evaluated = evaluateConstant(exp);\n        if (evaluated != null) {\n          const arg = p.arg && p.arg.content;\n          if (arg === \"class\") {\n            evaluated = shared.normalizeClass(evaluated);\n          } else if (arg === \"style\") {\n            evaluated = shared.stringifyStyle(shared.normalizeStyle(evaluated));\n          }\n          res += ` ${p.arg.content}=\"${shared.escapeHtml(\n            evaluated\n          )}\"`;\n        }\n      } else if (p.name === \"html\") {\n        innerHTML = evaluateConstant(p.exp);\n      } else if (p.name === \"text\") {\n        innerHTML = shared.escapeHtml(\n          shared.toDisplayString(evaluateConstant(p.exp))\n        );\n      }\n    }\n  }\n  if (context.scopeId) {\n    res += ` ${context.scopeId}`;\n  }\n  res += `>`;\n  if (innerHTML) {\n    res += innerHTML;\n  } else {\n    for (let i = 0; i < node.children.length; i++) {\n      res += stringifyNode(node.children[i], context);\n    }\n  }\n  if (!shared.isVoidTag(node.tag)) {\n    res += `</${node.tag}>`;\n  }\n  return res;\n}\nfunction evaluateConstant(exp) {\n  if (exp.type === 4) {\n    return new Function(`return (${exp.content})`)();\n  } else {\n    let res = ``;\n    exp.children.forEach((c) => {\n      if (shared.isString(c) || shared.isSymbol(c)) {\n        return;\n      }\n      if (c.type === 2) {\n        res += c.content;\n      } else if (c.type === 5) {\n        res += shared.toDisplayString(evaluateConstant(c.content));\n      } else {\n        res += evaluateConstant(c);\n      }\n    });\n    return res;\n  }\n}\n\nconst ignoreSideEffectTags = (node, context) => {\n  if (node.type === 1 && node.tagType === 0 && (node.tag === \"script\" || node.tag === \"style\")) {\n    context.onError(\n      createDOMCompilerError(\n        63,\n        node.loc\n      )\n    );\n    context.removeNode();\n  }\n};\n\nfunction isValidHTMLNesting(parent, child) {\n  if (parent === \"template\") {\n    return true;\n  }\n  if (parent in onlyValidChildren) {\n    return onlyValidChildren[parent].has(child);\n  }\n  if (child in onlyValidParents) {\n    return onlyValidParents[child].has(parent);\n  }\n  if (parent in knownInvalidChildren) {\n    if (knownInvalidChildren[parent].has(child)) return false;\n  }\n  if (child in knownInvalidParents) {\n    if (knownInvalidParents[child].has(parent)) return false;\n  }\n  return true;\n}\nconst headings = /* @__PURE__ */ new Set([\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"]);\nconst emptySet = /* @__PURE__ */ new Set([]);\nconst onlyValidChildren = {\n  head: /* @__PURE__ */ new Set([\n    \"base\",\n    \"basefront\",\n    \"bgsound\",\n    \"link\",\n    \"meta\",\n    \"title\",\n    \"noscript\",\n    \"noframes\",\n    \"style\",\n    \"script\",\n    \"template\"\n  ]),\n  optgroup: /* @__PURE__ */ new Set([\"option\"]),\n  select: /* @__PURE__ */ new Set([\"optgroup\", \"option\", \"hr\"]),\n  // table\n  table: /* @__PURE__ */ new Set([\"caption\", \"colgroup\", \"tbody\", \"tfoot\", \"thead\"]),\n  tr: /* @__PURE__ */ new Set([\"td\", \"th\"]),\n  colgroup: /* @__PURE__ */ new Set([\"col\"]),\n  tbody: /* @__PURE__ */ new Set([\"tr\"]),\n  thead: /* @__PURE__ */ new Set([\"tr\"]),\n  tfoot: /* @__PURE__ */ new Set([\"tr\"]),\n  // these elements can not have any children elements\n  script: emptySet,\n  iframe: emptySet,\n  option: emptySet,\n  textarea: emptySet,\n  style: emptySet,\n  title: emptySet\n};\nconst onlyValidParents = {\n  // sections\n  html: emptySet,\n  body: /* @__PURE__ */ new Set([\"html\"]),\n  head: /* @__PURE__ */ new Set([\"html\"]),\n  // table\n  td: /* @__PURE__ */ new Set([\"tr\"]),\n  colgroup: /* @__PURE__ */ new Set([\"table\"]),\n  caption: /* @__PURE__ */ new Set([\"table\"]),\n  tbody: /* @__PURE__ */ new Set([\"table\"]),\n  tfoot: /* @__PURE__ */ new Set([\"table\"]),\n  col: /* @__PURE__ */ new Set([\"colgroup\"]),\n  th: /* @__PURE__ */ new Set([\"tr\"]),\n  thead: /* @__PURE__ */ new Set([\"table\"]),\n  tr: /* @__PURE__ */ new Set([\"tbody\", \"thead\", \"tfoot\"]),\n  // data list\n  dd: /* @__PURE__ */ new Set([\"dl\", \"div\"]),\n  dt: /* @__PURE__ */ new Set([\"dl\", \"div\"]),\n  // other\n  figcaption: /* @__PURE__ */ new Set([\"figure\"]),\n  // li: new Set([\"ul\", \"ol\"]),\n  summary: /* @__PURE__ */ new Set([\"details\"]),\n  area: /* @__PURE__ */ new Set([\"map\"])\n};\nconst knownInvalidChildren = {\n  p: /* @__PURE__ */ new Set([\n    \"address\",\n    \"article\",\n    \"aside\",\n    \"blockquote\",\n    \"center\",\n    \"details\",\n    \"dialog\",\n    \"dir\",\n    \"div\",\n    \"dl\",\n    \"fieldset\",\n    \"figure\",\n    \"footer\",\n    \"form\",\n    \"h1\",\n    \"h2\",\n    \"h3\",\n    \"h4\",\n    \"h5\",\n    \"h6\",\n    \"header\",\n    \"hgroup\",\n    \"hr\",\n    \"li\",\n    \"main\",\n    \"nav\",\n    \"menu\",\n    \"ol\",\n    \"p\",\n    \"pre\",\n    \"section\",\n    \"table\",\n    \"ul\"\n  ]),\n  svg: /* @__PURE__ */ new Set([\n    \"b\",\n    \"blockquote\",\n    \"br\",\n    \"code\",\n    \"dd\",\n    \"div\",\n    \"dl\",\n    \"dt\",\n    \"em\",\n    \"embed\",\n    \"h1\",\n    \"h2\",\n    \"h3\",\n    \"h4\",\n    \"h5\",\n    \"h6\",\n    \"hr\",\n    \"i\",\n    \"img\",\n    \"li\",\n    \"menu\",\n    \"meta\",\n    \"ol\",\n    \"p\",\n    \"pre\",\n    \"ruby\",\n    \"s\",\n    \"small\",\n    \"span\",\n    \"strong\",\n    \"sub\",\n    \"sup\",\n    \"table\",\n    \"u\",\n    \"ul\",\n    \"var\"\n  ])\n};\nconst knownInvalidParents = {\n  a: /* @__PURE__ */ new Set([\"a\"]),\n  button: /* @__PURE__ */ new Set([\"button\"]),\n  dd: /* @__PURE__ */ new Set([\"dd\", \"dt\"]),\n  dt: /* @__PURE__ */ new Set([\"dd\", \"dt\"]),\n  form: /* @__PURE__ */ new Set([\"form\"]),\n  li: /* @__PURE__ */ new Set([\"li\"]),\n  h1: headings,\n  h2: headings,\n  h3: headings,\n  h4: headings,\n  h5: headings,\n  h6: headings\n};\n\nconst validateHtmlNesting = (node, context) => {\n  if (node.type === 1 && node.tagType === 0 && context.parent && context.parent.type === 1 && context.parent.tagType === 0 && !isValidHTMLNesting(context.parent.tag, node.tag)) {\n    const error = new SyntaxError(\n      `<${node.tag}> cannot be child of <${context.parent.tag}>, according to HTML specifications. This can cause hydration errors or potentially disrupt future functionality.`\n    );\n    error.loc = node.loc;\n    context.onWarn(error);\n  }\n};\n\nconst DOMNodeTransforms = [\n  transformStyle,\n  ...[transformTransition, validateHtmlNesting] \n];\nconst DOMDirectiveTransforms = {\n  cloak: compilerCore.noopDirectiveTransform,\n  html: transformVHtml,\n  text: transformVText,\n  model: transformModel,\n  // override compiler-core\n  on: transformOn,\n  // override compiler-core\n  show: transformShow\n};\nfunction compile(src, options = {}) {\n  return compilerCore.baseCompile(\n    src,\n    shared.extend({}, parserOptions, options, {\n      nodeTransforms: [\n        // ignore <script> and <tag>\n        // this is not put inside DOMNodeTransforms because that list is used\n        // by compiler-ssr to generate vnode fallback branches\n        ignoreSideEffectTags,\n        ...DOMNodeTransforms,\n        ...options.nodeTransforms || []\n      ],\n      directiveTransforms: shared.extend(\n        {},\n        DOMDirectiveTransforms,\n        options.directiveTransforms || {}\n      ),\n      transformHoist: stringifyStatic\n    })\n  );\n}\nfunction parse(template, options = {}) {\n  return compilerCore.baseParse(template, shared.extend({}, parserOptions, options));\n}\n\nexports.DOMDirectiveTransforms = DOMDirectiveTransforms;\nexports.DOMErrorCodes = DOMErrorCodes;\nexports.DOMErrorMessages = DOMErrorMessages;\nexports.DOMNodeTransforms = DOMNodeTransforms;\nexports.TRANSITION = TRANSITION;\nexports.TRANSITION_GROUP = TRANSITION_GROUP;\nexports.V_MODEL_CHECKBOX = V_MODEL_CHECKBOX;\nexports.V_MODEL_DYNAMIC = V_MODEL_DYNAMIC;\nexports.V_MODEL_RADIO = V_MODEL_RADIO;\nexports.V_MODEL_SELECT = V_MODEL_SELECT;\nexports.V_MODEL_TEXT = V_MODEL_TEXT;\nexports.V_ON_WITH_KEYS = V_ON_WITH_KEYS;\nexports.V_ON_WITH_MODIFIERS = V_ON_WITH_MODIFIERS;\nexports.V_SHOW = V_SHOW;\nexports.compile = compile;\nexports.createDOMCompilerError = createDOMCompilerError;\nexports.parse = parse;\nexports.parserOptions = parserOptions;\nexports.transformStyle = transformStyle;\nObject.keys(compilerCore).forEach(function (k) {\n  if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) exports[k] = compilerCore[k];\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B2dWUrY29tcGlsZXItZG9tQDMuNS4yMi9ub2RlX21vZHVsZXMvQHZ1ZS9jb21waWxlci1kb20vZGlzdC9jb21waWxlci1kb20uY2pzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdELG1CQUFtQixtQkFBTyxDQUFDLDhJQUFvQjtBQUMvQyxhQUFhLG1CQUFPLENBQUMsa0hBQWE7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxXQUFXO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLFdBQVc7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsTUFBTTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixNQUFNO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBLFVBQVUseUJBQXlCO0FBQ25DLFlBQVksc0RBQXNEO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixZQUFZLEVBQUUsZ0JBQWdCLG9FQUFvRSxnQkFBZ0I7QUFDck07QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxVQUFVLFdBQVc7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDRCQUE0QjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHFCQUFxQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0NBQWdDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0Esb0JBQW9CLG1DQUFtQztBQUN2RDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsY0FBYyxxQkFBcUIsWUFBWTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EscUJBQXFCLGNBQWMsSUFBSTtBQUN2QztBQUNBLFlBQVk7QUFDWjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFlBQVk7QUFDL0MsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFNBQVMsd0JBQXdCLG1CQUFtQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHFDQUFxQztBQUNyQywwREFBMEQ7QUFDMUQ7O0FBRUEsOEJBQThCO0FBQzlCLHFCQUFxQjtBQUNyQix3QkFBd0I7QUFDeEIseUJBQXlCO0FBQ3pCLGtCQUFrQjtBQUNsQix3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCLHVCQUF1QjtBQUN2QixxQkFBcUI7QUFDckIsc0JBQXNCO0FBQ3RCLG9CQUFvQjtBQUNwQixzQkFBc0I7QUFDdEIsMkJBQTJCO0FBQzNCLGNBQWM7QUFDZCxlQUFlO0FBQ2YsOEJBQThCO0FBQzlCLGFBQWE7QUFDYixxQkFBcUI7QUFDckIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJFOlxcT0NULUJPVU5UWVxcZmhldm0tcmVhY3QtdGVtcGxhdGVcXG5vZGVfbW9kdWxlc1xcLnBucG1cXEB2dWUrY29tcGlsZXItZG9tQDMuNS4yMlxcbm9kZV9tb2R1bGVzXFxAdnVlXFxjb21waWxlci1kb21cXGRpc3RcXGNvbXBpbGVyLWRvbS5janMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4qIEB2dWUvY29tcGlsZXItZG9tIHYzLjUuMjJcbiogKGMpIDIwMTgtcHJlc2VudCBZdXhpIChFdmFuKSBZb3UgYW5kIFZ1ZSBjb250cmlidXRvcnNcbiogQGxpY2Vuc2UgTUlUXG4qKi9cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNvbXBpbGVyQ29yZSA9IHJlcXVpcmUoJ0B2dWUvY29tcGlsZXItY29yZScpO1xudmFyIHNoYXJlZCA9IHJlcXVpcmUoJ0B2dWUvc2hhcmVkJyk7XG5cbmNvbnN0IFZfTU9ERUxfUkFESU8gPSBTeW1ib2woYHZNb2RlbFJhZGlvYCApO1xuY29uc3QgVl9NT0RFTF9DSEVDS0JPWCA9IFN5bWJvbChcbiAgYHZNb2RlbENoZWNrYm94YCBcbik7XG5jb25zdCBWX01PREVMX1RFWFQgPSBTeW1ib2woYHZNb2RlbFRleHRgICk7XG5jb25zdCBWX01PREVMX1NFTEVDVCA9IFN5bWJvbChcbiAgYHZNb2RlbFNlbGVjdGAgXG4pO1xuY29uc3QgVl9NT0RFTF9EWU5BTUlDID0gU3ltYm9sKFxuICBgdk1vZGVsRHluYW1pY2AgXG4pO1xuY29uc3QgVl9PTl9XSVRIX01PRElGSUVSUyA9IFN5bWJvbChcbiAgYHZPbk1vZGlmaWVyc0d1YXJkYCBcbik7XG5jb25zdCBWX09OX1dJVEhfS0VZUyA9IFN5bWJvbChcbiAgYHZPbktleXNHdWFyZGAgXG4pO1xuY29uc3QgVl9TSE9XID0gU3ltYm9sKGB2U2hvd2AgKTtcbmNvbnN0IFRSQU5TSVRJT04gPSBTeW1ib2woYFRyYW5zaXRpb25gICk7XG5jb25zdCBUUkFOU0lUSU9OX0dST1VQID0gU3ltYm9sKFxuICBgVHJhbnNpdGlvbkdyb3VwYCBcbik7XG5jb21waWxlckNvcmUucmVnaXN0ZXJSdW50aW1lSGVscGVycyh7XG4gIFtWX01PREVMX1JBRElPXTogYHZNb2RlbFJhZGlvYCxcbiAgW1ZfTU9ERUxfQ0hFQ0tCT1hdOiBgdk1vZGVsQ2hlY2tib3hgLFxuICBbVl9NT0RFTF9URVhUXTogYHZNb2RlbFRleHRgLFxuICBbVl9NT0RFTF9TRUxFQ1RdOiBgdk1vZGVsU2VsZWN0YCxcbiAgW1ZfTU9ERUxfRFlOQU1JQ106IGB2TW9kZWxEeW5hbWljYCxcbiAgW1ZfT05fV0lUSF9NT0RJRklFUlNdOiBgd2l0aE1vZGlmaWVyc2AsXG4gIFtWX09OX1dJVEhfS0VZU106IGB3aXRoS2V5c2AsXG4gIFtWX1NIT1ddOiBgdlNob3dgLFxuICBbVFJBTlNJVElPTl06IGBUcmFuc2l0aW9uYCxcbiAgW1RSQU5TSVRJT05fR1JPVVBdOiBgVHJhbnNpdGlvbkdyb3VwYFxufSk7XG5cbmNvbnN0IHBhcnNlck9wdGlvbnMgPSB7XG4gIHBhcnNlTW9kZTogXCJodG1sXCIsXG4gIGlzVm9pZFRhZzogc2hhcmVkLmlzVm9pZFRhZyxcbiAgaXNOYXRpdmVUYWc6ICh0YWcpID0+IHNoYXJlZC5pc0hUTUxUYWcodGFnKSB8fCBzaGFyZWQuaXNTVkdUYWcodGFnKSB8fCBzaGFyZWQuaXNNYXRoTUxUYWcodGFnKSxcbiAgaXNQcmVUYWc6ICh0YWcpID0+IHRhZyA9PT0gXCJwcmVcIixcbiAgaXNJZ25vcmVOZXdsaW5lVGFnOiAodGFnKSA9PiB0YWcgPT09IFwicHJlXCIgfHwgdGFnID09PSBcInRleHRhcmVhXCIsXG4gIGRlY29kZUVudGl0aWVzOiB2b2lkIDAsXG4gIGlzQnVpbHRJbkNvbXBvbmVudDogKHRhZykgPT4ge1xuICAgIGlmICh0YWcgPT09IFwiVHJhbnNpdGlvblwiIHx8IHRhZyA9PT0gXCJ0cmFuc2l0aW9uXCIpIHtcbiAgICAgIHJldHVybiBUUkFOU0lUSU9OO1xuICAgIH0gZWxzZSBpZiAodGFnID09PSBcIlRyYW5zaXRpb25Hcm91cFwiIHx8IHRhZyA9PT0gXCJ0cmFuc2l0aW9uLWdyb3VwXCIpIHtcbiAgICAgIHJldHVybiBUUkFOU0lUSU9OX0dST1VQO1xuICAgIH1cbiAgfSxcbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvcGFyc2luZy5odG1sI3RyZWUtY29uc3RydWN0aW9uLWRpc3BhdGNoZXJcbiAgZ2V0TmFtZXNwYWNlKHRhZywgcGFyZW50LCByb290TmFtZXNwYWNlKSB7XG4gICAgbGV0IG5zID0gcGFyZW50ID8gcGFyZW50Lm5zIDogcm9vdE5hbWVzcGFjZTtcbiAgICBpZiAocGFyZW50ICYmIG5zID09PSAyKSB7XG4gICAgICBpZiAocGFyZW50LnRhZyA9PT0gXCJhbm5vdGF0aW9uLXhtbFwiKSB7XG4gICAgICAgIGlmICh0YWcgPT09IFwic3ZnXCIpIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyZW50LnByb3BzLnNvbWUoXG4gICAgICAgICAgKGEpID0+IGEudHlwZSA9PT0gNiAmJiBhLm5hbWUgPT09IFwiZW5jb2RpbmdcIiAmJiBhLnZhbHVlICE9IG51bGwgJiYgKGEudmFsdWUuY29udGVudCA9PT0gXCJ0ZXh0L2h0bWxcIiB8fCBhLnZhbHVlLmNvbnRlbnQgPT09IFwiYXBwbGljYXRpb24veGh0bWwreG1sXCIpXG4gICAgICAgICkpIHtcbiAgICAgICAgICBucyA9IDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoL15tKD86W2lvbnNdfHRleHQpJC8udGVzdChwYXJlbnQudGFnKSAmJiB0YWcgIT09IFwibWdseXBoXCIgJiYgdGFnICE9PSBcIm1hbGlnbm1hcmtcIikge1xuICAgICAgICBucyA9IDA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwYXJlbnQgJiYgbnMgPT09IDEpIHtcbiAgICAgIGlmIChwYXJlbnQudGFnID09PSBcImZvcmVpZ25PYmplY3RcIiB8fCBwYXJlbnQudGFnID09PSBcImRlc2NcIiB8fCBwYXJlbnQudGFnID09PSBcInRpdGxlXCIpIHtcbiAgICAgICAgbnMgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobnMgPT09IDApIHtcbiAgICAgIGlmICh0YWcgPT09IFwic3ZnXCIpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICBpZiAodGFnID09PSBcIm1hdGhcIikge1xuICAgICAgICByZXR1cm4gMjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5zO1xuICB9XG59O1xuXG5jb25zdCB0cmFuc2Zvcm1TdHlsZSA9IChub2RlKSA9PiB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICBub2RlLnByb3BzLmZvckVhY2goKHAsIGkpID0+IHtcbiAgICAgIGlmIChwLnR5cGUgPT09IDYgJiYgcC5uYW1lID09PSBcInN0eWxlXCIgJiYgcC52YWx1ZSkge1xuICAgICAgICBub2RlLnByb3BzW2ldID0ge1xuICAgICAgICAgIHR5cGU6IDcsXG4gICAgICAgICAgbmFtZTogYGJpbmRgLFxuICAgICAgICAgIGFyZzogY29tcGlsZXJDb3JlLmNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oYHN0eWxlYCwgdHJ1ZSwgcC5sb2MpLFxuICAgICAgICAgIGV4cDogcGFyc2VJbmxpbmVDU1MocC52YWx1ZS5jb250ZW50LCBwLmxvYyksXG4gICAgICAgICAgbW9kaWZpZXJzOiBbXSxcbiAgICAgICAgICBsb2M6IHAubG9jXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5jb25zdCBwYXJzZUlubGluZUNTUyA9IChjc3NUZXh0LCBsb2MpID0+IHtcbiAgY29uc3Qgbm9ybWFsaXplZCA9IHNoYXJlZC5wYXJzZVN0cmluZ1N0eWxlKGNzc1RleHQpO1xuICByZXR1cm4gY29tcGlsZXJDb3JlLmNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oXG4gICAgSlNPTi5zdHJpbmdpZnkobm9ybWFsaXplZCksXG4gICAgZmFsc2UsXG4gICAgbG9jLFxuICAgIDNcbiAgKTtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoY29kZSwgbG9jKSB7XG4gIHJldHVybiBjb21waWxlckNvcmUuY3JlYXRlQ29tcGlsZXJFcnJvcihcbiAgICBjb2RlLFxuICAgIGxvYyxcbiAgICBET01FcnJvck1lc3NhZ2VzIFxuICApO1xufVxuY29uc3QgRE9NRXJyb3JDb2RlcyA9IHtcbiAgXCJYX1ZfSFRNTF9OT19FWFBSRVNTSU9OXCI6IDUzLFxuICBcIjUzXCI6IFwiWF9WX0hUTUxfTk9fRVhQUkVTU0lPTlwiLFxuICBcIlhfVl9IVE1MX1dJVEhfQ0hJTERSRU5cIjogNTQsXG4gIFwiNTRcIjogXCJYX1ZfSFRNTF9XSVRIX0NISUxEUkVOXCIsXG4gIFwiWF9WX1RFWFRfTk9fRVhQUkVTU0lPTlwiOiA1NSxcbiAgXCI1NVwiOiBcIlhfVl9URVhUX05PX0VYUFJFU1NJT05cIixcbiAgXCJYX1ZfVEVYVF9XSVRIX0NISUxEUkVOXCI6IDU2LFxuICBcIjU2XCI6IFwiWF9WX1RFWFRfV0lUSF9DSElMRFJFTlwiLFxuICBcIlhfVl9NT0RFTF9PTl9JTlZBTElEX0VMRU1FTlRcIjogNTcsXG4gIFwiNTdcIjogXCJYX1ZfTU9ERUxfT05fSU5WQUxJRF9FTEVNRU5UXCIsXG4gIFwiWF9WX01PREVMX0FSR19PTl9FTEVNRU5UXCI6IDU4LFxuICBcIjU4XCI6IFwiWF9WX01PREVMX0FSR19PTl9FTEVNRU5UXCIsXG4gIFwiWF9WX01PREVMX09OX0ZJTEVfSU5QVVRfRUxFTUVOVFwiOiA1OSxcbiAgXCI1OVwiOiBcIlhfVl9NT0RFTF9PTl9GSUxFX0lOUFVUX0VMRU1FTlRcIixcbiAgXCJYX1ZfTU9ERUxfVU5ORUNFU1NBUllfVkFMVUVcIjogNjAsXG4gIFwiNjBcIjogXCJYX1ZfTU9ERUxfVU5ORUNFU1NBUllfVkFMVUVcIixcbiAgXCJYX1ZfU0hPV19OT19FWFBSRVNTSU9OXCI6IDYxLFxuICBcIjYxXCI6IFwiWF9WX1NIT1dfTk9fRVhQUkVTU0lPTlwiLFxuICBcIlhfVFJBTlNJVElPTl9JTlZBTElEX0NISUxEUkVOXCI6IDYyLFxuICBcIjYyXCI6IFwiWF9UUkFOU0lUSU9OX0lOVkFMSURfQ0hJTERSRU5cIixcbiAgXCJYX0lHTk9SRURfU0lERV9FRkZFQ1RfVEFHXCI6IDYzLFxuICBcIjYzXCI6IFwiWF9JR05PUkVEX1NJREVfRUZGRUNUX1RBR1wiLFxuICBcIl9fRVhURU5EX1BPSU5UX19cIjogNjQsXG4gIFwiNjRcIjogXCJfX0VYVEVORF9QT0lOVF9fXCJcbn07XG5jb25zdCBET01FcnJvck1lc3NhZ2VzID0ge1xuICBbNTNdOiBgdi1odG1sIGlzIG1pc3NpbmcgZXhwcmVzc2lvbi5gLFxuICBbNTRdOiBgdi1odG1sIHdpbGwgb3ZlcnJpZGUgZWxlbWVudCBjaGlsZHJlbi5gLFxuICBbNTVdOiBgdi10ZXh0IGlzIG1pc3NpbmcgZXhwcmVzc2lvbi5gLFxuICBbNTZdOiBgdi10ZXh0IHdpbGwgb3ZlcnJpZGUgZWxlbWVudCBjaGlsZHJlbi5gLFxuICBbNTddOiBgdi1tb2RlbCBjYW4gb25seSBiZSB1c2VkIG9uIDxpbnB1dD4sIDx0ZXh0YXJlYT4gYW5kIDxzZWxlY3Q+IGVsZW1lbnRzLmAsXG4gIFs1OF06IGB2LW1vZGVsIGFyZ3VtZW50IGlzIG5vdCBzdXBwb3J0ZWQgb24gcGxhaW4gZWxlbWVudHMuYCxcbiAgWzU5XTogYHYtbW9kZWwgY2Fubm90IGJlIHVzZWQgb24gZmlsZSBpbnB1dHMgc2luY2UgdGhleSBhcmUgcmVhZC1vbmx5LiBVc2UgYSB2LW9uOmNoYW5nZSBsaXN0ZW5lciBpbnN0ZWFkLmAsXG4gIFs2MF06IGBVbm5lY2Vzc2FyeSB2YWx1ZSBiaW5kaW5nIHVzZWQgYWxvbmdzaWRlIHYtbW9kZWwuIEl0IHdpbGwgaW50ZXJmZXJlIHdpdGggdi1tb2RlbCdzIGJlaGF2aW9yLmAsXG4gIFs2MV06IGB2LXNob3cgaXMgbWlzc2luZyBleHByZXNzaW9uLmAsXG4gIFs2Ml06IGA8VHJhbnNpdGlvbj4gZXhwZWN0cyBleGFjdGx5IG9uZSBjaGlsZCBlbGVtZW50IG9yIGNvbXBvbmVudC5gLFxuICBbNjNdOiBgVGFncyB3aXRoIHNpZGUgZWZmZWN0ICg8c2NyaXB0PiBhbmQgPHN0eWxlPikgYXJlIGlnbm9yZWQgaW4gY2xpZW50IGNvbXBvbmVudCB0ZW1wbGF0ZXMuYFxufTtcblxuY29uc3QgdHJhbnNmb3JtVkh0bWwgPSAoZGlyLCBub2RlLCBjb250ZXh0KSA9PiB7XG4gIGNvbnN0IHsgZXhwLCBsb2MgfSA9IGRpcjtcbiAgaWYgKCFleHApIHtcbiAgICBjb250ZXh0Lm9uRXJyb3IoXG4gICAgICBjcmVhdGVET01Db21waWxlckVycm9yKDUzLCBsb2MpXG4gICAgKTtcbiAgfVxuICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICBjb250ZXh0Lm9uRXJyb3IoXG4gICAgICBjcmVhdGVET01Db21waWxlckVycm9yKDU0LCBsb2MpXG4gICAgKTtcbiAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwcm9wczogW1xuICAgICAgY29tcGlsZXJDb3JlLmNyZWF0ZU9iamVjdFByb3BlcnR5KFxuICAgICAgICBjb21waWxlckNvcmUuY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgaW5uZXJIVE1MYCwgdHJ1ZSwgbG9jKSxcbiAgICAgICAgZXhwIHx8IGNvbXBpbGVyQ29yZS5jcmVhdGVTaW1wbGVFeHByZXNzaW9uKFwiXCIsIHRydWUpXG4gICAgICApXG4gICAgXVxuICB9O1xufTtcblxuY29uc3QgdHJhbnNmb3JtVlRleHQgPSAoZGlyLCBub2RlLCBjb250ZXh0KSA9PiB7XG4gIGNvbnN0IHsgZXhwLCBsb2MgfSA9IGRpcjtcbiAgaWYgKCFleHApIHtcbiAgICBjb250ZXh0Lm9uRXJyb3IoXG4gICAgICBjcmVhdGVET01Db21waWxlckVycm9yKDU1LCBsb2MpXG4gICAgKTtcbiAgfVxuICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICBjb250ZXh0Lm9uRXJyb3IoXG4gICAgICBjcmVhdGVET01Db21waWxlckVycm9yKDU2LCBsb2MpXG4gICAgKTtcbiAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwcm9wczogW1xuICAgICAgY29tcGlsZXJDb3JlLmNyZWF0ZU9iamVjdFByb3BlcnR5KFxuICAgICAgICBjb21waWxlckNvcmUuY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgdGV4dENvbnRlbnRgLCB0cnVlKSxcbiAgICAgICAgZXhwID8gY29tcGlsZXJDb3JlLmdldENvbnN0YW50VHlwZShleHAsIGNvbnRleHQpID4gMCA/IGV4cCA6IGNvbXBpbGVyQ29yZS5jcmVhdGVDYWxsRXhwcmVzc2lvbihcbiAgICAgICAgICBjb250ZXh0LmhlbHBlclN0cmluZyhjb21waWxlckNvcmUuVE9fRElTUExBWV9TVFJJTkcpLFxuICAgICAgICAgIFtleHBdLFxuICAgICAgICAgIGxvY1xuICAgICAgICApIDogY29tcGlsZXJDb3JlLmNyZWF0ZVNpbXBsZUV4cHJlc3Npb24oXCJcIiwgdHJ1ZSlcbiAgICAgIClcbiAgICBdXG4gIH07XG59O1xuXG5jb25zdCB0cmFuc2Zvcm1Nb2RlbCA9IChkaXIsIG5vZGUsIGNvbnRleHQpID0+IHtcbiAgY29uc3QgYmFzZVJlc3VsdCA9IGNvbXBpbGVyQ29yZS50cmFuc2Zvcm1Nb2RlbChkaXIsIG5vZGUsIGNvbnRleHQpO1xuICBpZiAoIWJhc2VSZXN1bHQucHJvcHMubGVuZ3RoIHx8IG5vZGUudGFnVHlwZSA9PT0gMSkge1xuICAgIHJldHVybiBiYXNlUmVzdWx0O1xuICB9XG4gIGlmIChkaXIuYXJnKSB7XG4gICAgY29udGV4dC5vbkVycm9yKFxuICAgICAgY3JlYXRlRE9NQ29tcGlsZXJFcnJvcihcbiAgICAgICAgNTgsXG4gICAgICAgIGRpci5hcmcubG9jXG4gICAgICApXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiBjaGVja0R1cGxpY2F0ZWRWYWx1ZSgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGNvbXBpbGVyQ29yZS5maW5kRGlyKG5vZGUsIFwiYmluZFwiKTtcbiAgICBpZiAodmFsdWUgJiYgY29tcGlsZXJDb3JlLmlzU3RhdGljQXJnT2YodmFsdWUuYXJnLCBcInZhbHVlXCIpKSB7XG4gICAgICBjb250ZXh0Lm9uRXJyb3IoXG4gICAgICAgIGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoXG4gICAgICAgICAgNjAsXG4gICAgICAgICAgdmFsdWUubG9jXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHsgdGFnIH0gPSBub2RlO1xuICBjb25zdCBpc0N1c3RvbUVsZW1lbnQgPSBjb250ZXh0LmlzQ3VzdG9tRWxlbWVudCh0YWcpO1xuICBpZiAodGFnID09PSBcImlucHV0XCIgfHwgdGFnID09PSBcInRleHRhcmVhXCIgfHwgdGFnID09PSBcInNlbGVjdFwiIHx8IGlzQ3VzdG9tRWxlbWVudCkge1xuICAgIGxldCBkaXJlY3RpdmVUb1VzZSA9IFZfTU9ERUxfVEVYVDtcbiAgICBsZXQgaXNJbnZhbGlkVHlwZSA9IGZhbHNlO1xuICAgIGlmICh0YWcgPT09IFwiaW5wdXRcIiB8fCBpc0N1c3RvbUVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBjb21waWxlckNvcmUuZmluZFByb3Aobm9kZSwgYHR5cGVgKTtcbiAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgIGlmICh0eXBlLnR5cGUgPT09IDcpIHtcbiAgICAgICAgICBkaXJlY3RpdmVUb1VzZSA9IFZfTU9ERUxfRFlOQU1JQztcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlLnZhbHVlKSB7XG4gICAgICAgICAgc3dpdGNoICh0eXBlLnZhbHVlLmNvbnRlbnQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJyYWRpb1wiOlxuICAgICAgICAgICAgICBkaXJlY3RpdmVUb1VzZSA9IFZfTU9ERUxfUkFESU87XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImNoZWNrYm94XCI6XG4gICAgICAgICAgICAgIGRpcmVjdGl2ZVRvVXNlID0gVl9NT0RFTF9DSEVDS0JPWDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZmlsZVwiOlxuICAgICAgICAgICAgICBpc0ludmFsaWRUeXBlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY29udGV4dC5vbkVycm9yKFxuICAgICAgICAgICAgICAgIGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoXG4gICAgICAgICAgICAgICAgICA1OSxcbiAgICAgICAgICAgICAgICAgIGRpci5sb2NcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgY2hlY2tEdXBsaWNhdGVkVmFsdWUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNvbXBpbGVyQ29yZS5oYXNEeW5hbWljS2V5VkJpbmQobm9kZSkpIHtcbiAgICAgICAgZGlyZWN0aXZlVG9Vc2UgPSBWX01PREVMX0RZTkFNSUM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGVja0R1cGxpY2F0ZWRWYWx1ZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGFnID09PSBcInNlbGVjdFwiKSB7XG4gICAgICBkaXJlY3RpdmVUb1VzZSA9IFZfTU9ERUxfU0VMRUNUO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGVja0R1cGxpY2F0ZWRWYWx1ZSgpO1xuICAgIH1cbiAgICBpZiAoIWlzSW52YWxpZFR5cGUpIHtcbiAgICAgIGJhc2VSZXN1bHQubmVlZFJ1bnRpbWUgPSBjb250ZXh0LmhlbHBlcihkaXJlY3RpdmVUb1VzZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnRleHQub25FcnJvcihcbiAgICAgIGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoXG4gICAgICAgIDU3LFxuICAgICAgICBkaXIubG9jXG4gICAgICApXG4gICAgKTtcbiAgfVxuICBiYXNlUmVzdWx0LnByb3BzID0gYmFzZVJlc3VsdC5wcm9wcy5maWx0ZXIoXG4gICAgKHApID0+ICEocC5rZXkudHlwZSA9PT0gNCAmJiBwLmtleS5jb250ZW50ID09PSBcIm1vZGVsVmFsdWVcIilcbiAgKTtcbiAgcmV0dXJuIGJhc2VSZXN1bHQ7XG59O1xuXG5jb25zdCBpc0V2ZW50T3B0aW9uTW9kaWZpZXIgPSAvKiBAX19QVVJFX18gKi8gc2hhcmVkLm1ha2VNYXAoYHBhc3NpdmUsb25jZSxjYXB0dXJlYCk7XG5jb25zdCBpc05vbktleU1vZGlmaWVyID0gLyogQF9fUFVSRV9fICovIHNoYXJlZC5tYWtlTWFwKFxuICAvLyBldmVudCBwcm9wYWdhdGlvbiBtYW5hZ2VtZW50XG4gIGBzdG9wLHByZXZlbnQsc2VsZixjdHJsLHNoaWZ0LGFsdCxtZXRhLGV4YWN0LG1pZGRsZWBcbik7XG5jb25zdCBtYXliZUtleU1vZGlmaWVyID0gLyogQF9fUFVSRV9fICovIHNoYXJlZC5tYWtlTWFwKFwibGVmdCxyaWdodFwiKTtcbmNvbnN0IGlzS2V5Ym9hcmRFdmVudCA9IC8qIEBfX1BVUkVfXyAqLyBzaGFyZWQubWFrZU1hcChgb25rZXl1cCxvbmtleWRvd24sb25rZXlwcmVzc2ApO1xuY29uc3QgcmVzb2x2ZU1vZGlmaWVycyA9IChrZXksIG1vZGlmaWVycywgY29udGV4dCwgbG9jKSA9PiB7XG4gIGNvbnN0IGtleU1vZGlmaWVycyA9IFtdO1xuICBjb25zdCBub25LZXlNb2RpZmllcnMgPSBbXTtcbiAgY29uc3QgZXZlbnRPcHRpb25Nb2RpZmllcnMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtb2RpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBtb2RpZmllciA9IG1vZGlmaWVyc1tpXS5jb250ZW50O1xuICAgIGlmIChtb2RpZmllciA9PT0gXCJuYXRpdmVcIiAmJiBjb21waWxlckNvcmUuY2hlY2tDb21wYXRFbmFibGVkKFxuICAgICAgXCJDT01QSUxFUl9WX09OX05BVElWRVwiLFxuICAgICAgY29udGV4dCxcbiAgICAgIGxvY1xuICAgICkpIHtcbiAgICAgIGV2ZW50T3B0aW9uTW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xuICAgIH0gZWxzZSBpZiAoaXNFdmVudE9wdGlvbk1vZGlmaWVyKG1vZGlmaWVyKSkge1xuICAgICAgZXZlbnRPcHRpb25Nb2RpZmllcnMucHVzaChtb2RpZmllcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChtYXliZUtleU1vZGlmaWVyKG1vZGlmaWVyKSkge1xuICAgICAgICBpZiAoY29tcGlsZXJDb3JlLmlzU3RhdGljRXhwKGtleSkpIHtcbiAgICAgICAgICBpZiAoaXNLZXlib2FyZEV2ZW50KGtleS5jb250ZW50LnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICBrZXlNb2RpZmllcnMucHVzaChtb2RpZmllcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vbktleU1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAga2V5TW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xuICAgICAgICAgIG5vbktleU1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzTm9uS2V5TW9kaWZpZXIobW9kaWZpZXIpKSB7XG4gICAgICAgICAgbm9uS2V5TW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGtleU1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGtleU1vZGlmaWVycyxcbiAgICBub25LZXlNb2RpZmllcnMsXG4gICAgZXZlbnRPcHRpb25Nb2RpZmllcnNcbiAgfTtcbn07XG5jb25zdCB0cmFuc2Zvcm1DbGljayA9IChrZXksIGV2ZW50KSA9PiB7XG4gIGNvbnN0IGlzU3RhdGljQ2xpY2sgPSBjb21waWxlckNvcmUuaXNTdGF0aWNFeHAoa2V5KSAmJiBrZXkuY29udGVudC50b0xvd2VyQ2FzZSgpID09PSBcIm9uY2xpY2tcIjtcbiAgcmV0dXJuIGlzU3RhdGljQ2xpY2sgPyBjb21waWxlckNvcmUuY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihldmVudCwgdHJ1ZSkgOiBrZXkudHlwZSAhPT0gNCA/IGNvbXBpbGVyQ29yZS5jcmVhdGVDb21wb3VuZEV4cHJlc3Npb24oW1xuICAgIGAoYCxcbiAgICBrZXksXG4gICAgYCkgPT09IFwib25DbGlja1wiID8gXCIke2V2ZW50fVwiIDogKGAsXG4gICAga2V5LFxuICAgIGApYFxuICBdKSA6IGtleTtcbn07XG5jb25zdCB0cmFuc2Zvcm1PbiA9IChkaXIsIG5vZGUsIGNvbnRleHQpID0+IHtcbiAgcmV0dXJuIGNvbXBpbGVyQ29yZS50cmFuc2Zvcm1PbihkaXIsIG5vZGUsIGNvbnRleHQsIChiYXNlUmVzdWx0KSA9PiB7XG4gICAgY29uc3QgeyBtb2RpZmllcnMgfSA9IGRpcjtcbiAgICBpZiAoIW1vZGlmaWVycy5sZW5ndGgpIHJldHVybiBiYXNlUmVzdWx0O1xuICAgIGxldCB7IGtleSwgdmFsdWU6IGhhbmRsZXJFeHAgfSA9IGJhc2VSZXN1bHQucHJvcHNbMF07XG4gICAgY29uc3QgeyBrZXlNb2RpZmllcnMsIG5vbktleU1vZGlmaWVycywgZXZlbnRPcHRpb25Nb2RpZmllcnMgfSA9IHJlc29sdmVNb2RpZmllcnMoa2V5LCBtb2RpZmllcnMsIGNvbnRleHQsIGRpci5sb2MpO1xuICAgIGlmIChub25LZXlNb2RpZmllcnMuaW5jbHVkZXMoXCJyaWdodFwiKSkge1xuICAgICAga2V5ID0gdHJhbnNmb3JtQ2xpY2soa2V5LCBgb25Db250ZXh0bWVudWApO1xuICAgIH1cbiAgICBpZiAobm9uS2V5TW9kaWZpZXJzLmluY2x1ZGVzKFwibWlkZGxlXCIpKSB7XG4gICAgICBrZXkgPSB0cmFuc2Zvcm1DbGljayhrZXksIGBvbk1vdXNldXBgKTtcbiAgICB9XG4gICAgaWYgKG5vbktleU1vZGlmaWVycy5sZW5ndGgpIHtcbiAgICAgIGhhbmRsZXJFeHAgPSBjb21waWxlckNvcmUuY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoVl9PTl9XSVRIX01PRElGSUVSUyksIFtcbiAgICAgICAgaGFuZGxlckV4cCxcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkobm9uS2V5TW9kaWZpZXJzKVxuICAgICAgXSk7XG4gICAgfVxuICAgIGlmIChrZXlNb2RpZmllcnMubGVuZ3RoICYmIC8vIGlmIGV2ZW50IG5hbWUgaXMgZHluYW1pYywgYWx3YXlzIHdyYXAgd2l0aCBrZXlzIGd1YXJkXG4gICAgKCFjb21waWxlckNvcmUuaXNTdGF0aWNFeHAoa2V5KSB8fCBpc0tleWJvYXJkRXZlbnQoa2V5LmNvbnRlbnQudG9Mb3dlckNhc2UoKSkpKSB7XG4gICAgICBoYW5kbGVyRXhwID0gY29tcGlsZXJDb3JlLmNyZWF0ZUNhbGxFeHByZXNzaW9uKGNvbnRleHQuaGVscGVyKFZfT05fV0lUSF9LRVlTKSwgW1xuICAgICAgICBoYW5kbGVyRXhwLFxuICAgICAgICBKU09OLnN0cmluZ2lmeShrZXlNb2RpZmllcnMpXG4gICAgICBdKTtcbiAgICB9XG4gICAgaWYgKGV2ZW50T3B0aW9uTW9kaWZpZXJzLmxlbmd0aCkge1xuICAgICAgY29uc3QgbW9kaWZpZXJQb3N0Zml4ID0gZXZlbnRPcHRpb25Nb2RpZmllcnMubWFwKHNoYXJlZC5jYXBpdGFsaXplKS5qb2luKFwiXCIpO1xuICAgICAga2V5ID0gY29tcGlsZXJDb3JlLmlzU3RhdGljRXhwKGtleSkgPyBjb21waWxlckNvcmUuY3JlYXRlU2ltcGxlRXhwcmVzc2lvbihgJHtrZXkuY29udGVudH0ke21vZGlmaWVyUG9zdGZpeH1gLCB0cnVlKSA6IGNvbXBpbGVyQ29yZS5jcmVhdGVDb21wb3VuZEV4cHJlc3Npb24oW2AoYCwga2V5LCBgKSArIFwiJHttb2RpZmllclBvc3RmaXh9XCJgXSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBwcm9wczogW2NvbXBpbGVyQ29yZS5jcmVhdGVPYmplY3RQcm9wZXJ0eShrZXksIGhhbmRsZXJFeHApXVxuICAgIH07XG4gIH0pO1xufTtcblxuY29uc3QgdHJhbnNmb3JtU2hvdyA9IChkaXIsIG5vZGUsIGNvbnRleHQpID0+IHtcbiAgY29uc3QgeyBleHAsIGxvYyB9ID0gZGlyO1xuICBpZiAoIWV4cCkge1xuICAgIGNvbnRleHQub25FcnJvcihcbiAgICAgIGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoNjEsIGxvYylcbiAgICApO1xuICB9XG4gIHJldHVybiB7XG4gICAgcHJvcHM6IFtdLFxuICAgIG5lZWRSdW50aW1lOiBjb250ZXh0LmhlbHBlcihWX1NIT1cpXG4gIH07XG59O1xuXG5jb25zdCB0cmFuc2Zvcm1UcmFuc2l0aW9uID0gKG5vZGUsIGNvbnRleHQpID0+IHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSAmJiBub2RlLnRhZ1R5cGUgPT09IDEpIHtcbiAgICBjb25zdCBjb21wb25lbnQgPSBjb250ZXh0LmlzQnVpbHRJbkNvbXBvbmVudChub2RlLnRhZyk7XG4gICAgaWYgKGNvbXBvbmVudCA9PT0gVFJBTlNJVElPTikge1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKCFub2RlLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzTXVsdGlwbGVDaGlsZHJlbihub2RlKSkge1xuICAgICAgICAgIGNvbnRleHQub25FcnJvcihcbiAgICAgICAgICAgIGNyZWF0ZURPTUNvbXBpbGVyRXJyb3IoXG4gICAgICAgICAgICAgIDYyLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IG5vZGUuY2hpbGRyZW5bMF0ubG9jLnN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZDogbm9kZS5jaGlsZHJlbltub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDFdLmxvYy5lbmQsXG4gICAgICAgICAgICAgICAgc291cmNlOiBcIlwiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5jaGlsZHJlblswXTtcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IDEpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHAgb2YgY2hpbGQucHJvcHMpIHtcbiAgICAgICAgICAgIGlmIChwLnR5cGUgPT09IDcgJiYgcC5uYW1lID09PSBcInNob3dcIikge1xuICAgICAgICAgICAgICBub2RlLnByb3BzLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IDYsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJwZXJzaXN0ZWRcIixcbiAgICAgICAgICAgICAgICBuYW1lTG9jOiBub2RlLmxvYyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdm9pZCAwLFxuICAgICAgICAgICAgICAgIGxvYzogbm9kZS5sb2NcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfVxufTtcbmZ1bmN0aW9uIGhhc011bHRpcGxlQ2hpbGRyZW4obm9kZSkge1xuICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuLmZpbHRlcihcbiAgICAoYykgPT4gYy50eXBlICE9PSAzICYmICEoYy50eXBlID09PSAyICYmICFjLmNvbnRlbnQudHJpbSgpKVxuICApO1xuICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuWzBdO1xuICByZXR1cm4gY2hpbGRyZW4ubGVuZ3RoICE9PSAxIHx8IGNoaWxkLnR5cGUgPT09IDExIHx8IGNoaWxkLnR5cGUgPT09IDkgJiYgY2hpbGQuYnJhbmNoZXMuc29tZShoYXNNdWx0aXBsZUNoaWxkcmVuKTtcbn1cblxuY29uc3QgZXhwUmVwbGFjZVJFID0gL19fVlVFX0VYUF9TVEFSVF9fKC4qPylfX1ZVRV9FWFBfRU5EX18vZztcbmNvbnN0IHN0cmluZ2lmeVN0YXRpYyA9IChjaGlsZHJlbiwgY29udGV4dCwgcGFyZW50KSA9PiB7XG4gIGlmIChjb250ZXh0LnNjb3Blcy52U2xvdCA+IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaXNQYXJlbnRDYWNoZWQgPSBwYXJlbnQudHlwZSA9PT0gMSAmJiBwYXJlbnQuY29kZWdlbk5vZGUgJiYgcGFyZW50LmNvZGVnZW5Ob2RlLnR5cGUgPT09IDEzICYmIHBhcmVudC5jb2RlZ2VuTm9kZS5jaGlsZHJlbiAmJiAhc2hhcmVkLmlzQXJyYXkocGFyZW50LmNvZGVnZW5Ob2RlLmNoaWxkcmVuKSAmJiBwYXJlbnQuY29kZWdlbk5vZGUuY2hpbGRyZW4udHlwZSA9PT0gMjA7XG4gIGxldCBuYyA9IDA7XG4gIGxldCBlYyA9IDA7XG4gIGNvbnN0IGN1cnJlbnRDaHVuayA9IFtdO1xuICBjb25zdCBzdHJpbmdpZnlDdXJyZW50Q2h1bmsgPSAoY3VycmVudEluZGV4KSA9PiB7XG4gICAgaWYgKG5jID49IDIwIHx8IGVjID49IDUpIHtcbiAgICAgIGNvbnN0IHN0YXRpY0NhbGwgPSBjb21waWxlckNvcmUuY3JlYXRlQ2FsbEV4cHJlc3Npb24oY29udGV4dC5oZWxwZXIoY29tcGlsZXJDb3JlLkNSRUFURV9TVEFUSUMpLCBbXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgIGN1cnJlbnRDaHVuay5tYXAoKG5vZGUpID0+IHN0cmluZ2lmeU5vZGUobm9kZSwgY29udGV4dCkpLmpvaW4oXCJcIilcbiAgICAgICAgKS5yZXBsYWNlKGV4cFJlcGxhY2VSRSwgYFwiICsgJDEgKyBcImApLFxuICAgICAgICAvLyB0aGUgMm5kIGFyZ3VtZW50IGluZGljYXRlcyB0aGUgbnVtYmVyIG9mIERPTSBub2RlcyB0aGlzIHN0YXRpYyB2bm9kZVxuICAgICAgICAvLyB3aWxsIGluc2VydCAvIGh5ZHJhdGVcbiAgICAgICAgU3RyaW5nKGN1cnJlbnRDaHVuay5sZW5ndGgpXG4gICAgICBdKTtcbiAgICAgIGNvbnN0IGRlbGV0ZUNvdW50ID0gY3VycmVudENodW5rLmxlbmd0aCAtIDE7XG4gICAgICBpZiAoaXNQYXJlbnRDYWNoZWQpIHtcbiAgICAgICAgY2hpbGRyZW4uc3BsaWNlKFxuICAgICAgICAgIGN1cnJlbnRJbmRleCAtIGN1cnJlbnRDaHVuay5sZW5ndGgsXG4gICAgICAgICAgY3VycmVudENodW5rLmxlbmd0aCxcbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgc3RhdGljQ2FsbFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudENodW5rWzBdLmNvZGVnZW5Ob2RlLnZhbHVlID0gc3RhdGljQ2FsbDtcbiAgICAgICAgaWYgKGN1cnJlbnRDaHVuay5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGN1cnJlbnRJbmRleCAtIGN1cnJlbnRDaHVuay5sZW5ndGggKyAxLCBkZWxldGVDb3VudCk7XG4gICAgICAgICAgY29uc3QgY2FjaGVJbmRleCA9IGNvbnRleHQuY2FjaGVkLmluZGV4T2YoXG4gICAgICAgICAgICBjdXJyZW50Q2h1bmtbY3VycmVudENodW5rLmxlbmd0aCAtIDFdLmNvZGVnZW5Ob2RlXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoY2FjaGVJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpMiA9IGNhY2hlSW5kZXg7IGkyIDwgY29udGV4dC5jYWNoZWQubGVuZ3RoOyBpMisrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGMgPSBjb250ZXh0LmNhY2hlZFtpMl07XG4gICAgICAgICAgICAgIGlmIChjKSBjLmluZGV4IC09IGRlbGV0ZUNvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGV4dC5jYWNoZWQuc3BsaWNlKGNhY2hlSW5kZXggLSBkZWxldGVDb3VudCArIDEsIGRlbGV0ZUNvdW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWxldGVDb3VudDtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH07XG4gIGxldCBpID0gMDtcbiAgZm9yICg7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgY29uc3QgaXNDYWNoZWQgPSBpc1BhcmVudENhY2hlZCB8fCBnZXRDYWNoZWROb2RlKGNoaWxkKTtcbiAgICBpZiAoaXNDYWNoZWQpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGFuYWx5emVOb2RlKGNoaWxkKTtcbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgbmMgKz0gcmVzdWx0WzBdO1xuICAgICAgICBlYyArPSByZXN1bHRbMV07XG4gICAgICAgIGN1cnJlbnRDaHVuay5wdXNoKGNoaWxkKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICAgIGkgLT0gc3RyaW5naWZ5Q3VycmVudENodW5rKGkpO1xuICAgIG5jID0gMDtcbiAgICBlYyA9IDA7XG4gICAgY3VycmVudENodW5rLmxlbmd0aCA9IDA7XG4gIH1cbiAgc3RyaW5naWZ5Q3VycmVudENodW5rKGkpO1xufTtcbmNvbnN0IGdldENhY2hlZE5vZGUgPSAobm9kZSkgPT4ge1xuICBpZiAoKG5vZGUudHlwZSA9PT0gMSAmJiBub2RlLnRhZ1R5cGUgPT09IDAgfHwgbm9kZS50eXBlID09PSAxMikgJiYgbm9kZS5jb2RlZ2VuTm9kZSAmJiBub2RlLmNvZGVnZW5Ob2RlLnR5cGUgPT09IDIwKSB7XG4gICAgcmV0dXJuIG5vZGUuY29kZWdlbk5vZGU7XG4gIH1cbn07XG5jb25zdCBkYXRhQXJpYVJFID0gL14oPzpkYXRhfGFyaWEpLS87XG5jb25zdCBpc1N0cmluZ2lmaWFibGVBdHRyID0gKG5hbWUsIG5zKSA9PiB7XG4gIHJldHVybiAobnMgPT09IDAgPyBzaGFyZWQuaXNLbm93bkh0bWxBdHRyKG5hbWUpIDogbnMgPT09IDEgPyBzaGFyZWQuaXNLbm93blN2Z0F0dHIobmFtZSkgOiBucyA9PT0gMiA/IHNoYXJlZC5pc0tub3duTWF0aE1MQXR0cihuYW1lKSA6IGZhbHNlKSB8fCBkYXRhQXJpYVJFLnRlc3QobmFtZSk7XG59O1xuY29uc3QgaXNOb25TdHJpbmdpZmlhYmxlID0gLyogQF9fUFVSRV9fICovIHNoYXJlZC5tYWtlTWFwKFxuICBgY2FwdGlvbix0aGVhZCx0cix0aCx0Ym9keSx0ZCx0Zm9vdCxjb2xncm91cCxjb2xgXG4pO1xuZnVuY3Rpb24gYW5hbHl6ZU5vZGUobm9kZSkge1xuICBpZiAobm9kZS50eXBlID09PSAxICYmIGlzTm9uU3RyaW5naWZpYWJsZShub2RlLnRhZykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gMSAmJiBjb21waWxlckNvcmUuZmluZERpcihub2RlLCBcIm9uY2VcIiwgdHJ1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gMTIpIHtcbiAgICByZXR1cm4gWzEsIDBdO1xuICB9XG4gIGxldCBuYyA9IDE7XG4gIGxldCBlYyA9IG5vZGUucHJvcHMubGVuZ3RoID4gMCA/IDEgOiAwO1xuICBsZXQgYmFpbGVkID0gZmFsc2U7XG4gIGNvbnN0IGJhaWwgPSAoKSA9PiB7XG4gICAgYmFpbGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIGZ1bmN0aW9uIHdhbGsobm9kZTIpIHtcbiAgICBjb25zdCBpc09wdGlvblRhZyA9IG5vZGUyLnRhZyA9PT0gXCJvcHRpb25cIiAmJiBub2RlMi5ucyA9PT0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUyLnByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwID0gbm9kZTIucHJvcHNbaV07XG4gICAgICBpZiAocC50eXBlID09PSA2ICYmICFpc1N0cmluZ2lmaWFibGVBdHRyKHAubmFtZSwgbm9kZTIubnMpKSB7XG4gICAgICAgIHJldHVybiBiYWlsKCk7XG4gICAgICB9XG4gICAgICBpZiAocC50eXBlID09PSA3ICYmIHAubmFtZSA9PT0gXCJiaW5kXCIpIHtcbiAgICAgICAgaWYgKHAuYXJnICYmIChwLmFyZy50eXBlID09PSA4IHx8IHAuYXJnLmlzU3RhdGljICYmICFpc1N0cmluZ2lmaWFibGVBdHRyKHAuYXJnLmNvbnRlbnQsIG5vZGUyLm5zKSkpIHtcbiAgICAgICAgICByZXR1cm4gYmFpbCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwLmV4cCAmJiAocC5leHAudHlwZSA9PT0gOCB8fCBwLmV4cC5jb25zdFR5cGUgPCAzKSkge1xuICAgICAgICAgIHJldHVybiBiYWlsKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzT3B0aW9uVGFnICYmIGNvbXBpbGVyQ29yZS5pc1N0YXRpY0FyZ09mKHAuYXJnLCBcInZhbHVlXCIpICYmIHAuZXhwICYmICFwLmV4cC5pc1N0YXRpYykge1xuICAgICAgICAgIHJldHVybiBiYWlsKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlMi5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgbmMrKztcbiAgICAgIGNvbnN0IGNoaWxkID0gbm9kZTIuY2hpbGRyZW5baV07XG4gICAgICBpZiAoY2hpbGQudHlwZSA9PT0gMSkge1xuICAgICAgICBpZiAoY2hpbGQucHJvcHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGVjKys7XG4gICAgICAgIH1cbiAgICAgICAgd2FsayhjaGlsZCk7XG4gICAgICAgIGlmIChiYWlsZWQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHdhbGsobm9kZSkgPyBbbmMsIGVjXSA6IGZhbHNlO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5Tm9kZShub2RlLCBjb250ZXh0KSB7XG4gIGlmIChzaGFyZWQuaXNTdHJpbmcobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBpZiAoc2hhcmVkLmlzU3ltYm9sKG5vZGUpKSB7XG4gICAgcmV0dXJuIGBgO1xuICB9XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIHN0cmluZ2lmeUVsZW1lbnQobm9kZSwgY29udGV4dCk7XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIHNoYXJlZC5lc2NhcGVIdG1sKG5vZGUuY29udGVudCk7XG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIGA8IS0tJHtzaGFyZWQuZXNjYXBlSHRtbChub2RlLmNvbnRlbnQpfS0tPmA7XG4gICAgY2FzZSA1OlxuICAgICAgcmV0dXJuIHNoYXJlZC5lc2NhcGVIdG1sKHNoYXJlZC50b0Rpc3BsYXlTdHJpbmcoZXZhbHVhdGVDb25zdGFudChub2RlLmNvbnRlbnQpKSk7XG4gICAgY2FzZSA4OlxuICAgICAgcmV0dXJuIHNoYXJlZC5lc2NhcGVIdG1sKGV2YWx1YXRlQ29uc3RhbnQobm9kZSkpO1xuICAgIGNhc2UgMTI6XG4gICAgICByZXR1cm4gc3RyaW5naWZ5Tm9kZShub2RlLmNvbnRlbnQsIGNvbnRleHQpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gXCJcIjtcbiAgfVxufVxuZnVuY3Rpb24gc3RyaW5naWZ5RWxlbWVudChub2RlLCBjb250ZXh0KSB7XG4gIGxldCByZXMgPSBgPCR7bm9kZS50YWd9YDtcbiAgbGV0IGlubmVySFRNTCA9IFwiXCI7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5wcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHAgPSBub2RlLnByb3BzW2ldO1xuICAgIGlmIChwLnR5cGUgPT09IDYpIHtcbiAgICAgIHJlcyArPSBgICR7cC5uYW1lfWA7XG4gICAgICBpZiAocC52YWx1ZSkge1xuICAgICAgICByZXMgKz0gYD1cIiR7c2hhcmVkLmVzY2FwZUh0bWwocC52YWx1ZS5jb250ZW50KX1cImA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwLnR5cGUgPT09IDcpIHtcbiAgICAgIGlmIChwLm5hbWUgPT09IFwiYmluZFwiKSB7XG4gICAgICAgIGNvbnN0IGV4cCA9IHAuZXhwO1xuICAgICAgICBpZiAoZXhwLmNvbnRlbnRbMF0gPT09IFwiX1wiKSB7XG4gICAgICAgICAgcmVzICs9IGAgJHtwLmFyZy5jb250ZW50fT1cIl9fVlVFX0VYUF9TVEFSVF9fJHtleHAuY29udGVudH1fX1ZVRV9FWFBfRU5EX19cImA7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoYXJlZC5pc0Jvb2xlYW5BdHRyKHAuYXJnLmNvbnRlbnQpICYmIGV4cC5jb250ZW50ID09PSBcImZhbHNlXCIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZXZhbHVhdGVkID0gZXZhbHVhdGVDb25zdGFudChleHApO1xuICAgICAgICBpZiAoZXZhbHVhdGVkICE9IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBhcmcgPSBwLmFyZyAmJiBwLmFyZy5jb250ZW50O1xuICAgICAgICAgIGlmIChhcmcgPT09IFwiY2xhc3NcIikge1xuICAgICAgICAgICAgZXZhbHVhdGVkID0gc2hhcmVkLm5vcm1hbGl6ZUNsYXNzKGV2YWx1YXRlZCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChhcmcgPT09IFwic3R5bGVcIikge1xuICAgICAgICAgICAgZXZhbHVhdGVkID0gc2hhcmVkLnN0cmluZ2lmeVN0eWxlKHNoYXJlZC5ub3JtYWxpemVTdHlsZShldmFsdWF0ZWQpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzICs9IGAgJHtwLmFyZy5jb250ZW50fT1cIiR7c2hhcmVkLmVzY2FwZUh0bWwoXG4gICAgICAgICAgICBldmFsdWF0ZWRcbiAgICAgICAgICApfVwiYDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwLm5hbWUgPT09IFwiaHRtbFwiKSB7XG4gICAgICAgIGlubmVySFRNTCA9IGV2YWx1YXRlQ29uc3RhbnQocC5leHApO1xuICAgICAgfSBlbHNlIGlmIChwLm5hbWUgPT09IFwidGV4dFwiKSB7XG4gICAgICAgIGlubmVySFRNTCA9IHNoYXJlZC5lc2NhcGVIdG1sKFxuICAgICAgICAgIHNoYXJlZC50b0Rpc3BsYXlTdHJpbmcoZXZhbHVhdGVDb25zdGFudChwLmV4cCkpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChjb250ZXh0LnNjb3BlSWQpIHtcbiAgICByZXMgKz0gYCAke2NvbnRleHQuc2NvcGVJZH1gO1xuICB9XG4gIHJlcyArPSBgPmA7XG4gIGlmIChpbm5lckhUTUwpIHtcbiAgICByZXMgKz0gaW5uZXJIVE1MO1xuICB9IGVsc2Uge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzICs9IHN0cmluZ2lmeU5vZGUobm9kZS5jaGlsZHJlbltpXSwgY29udGV4dCk7XG4gICAgfVxuICB9XG4gIGlmICghc2hhcmVkLmlzVm9pZFRhZyhub2RlLnRhZykpIHtcbiAgICByZXMgKz0gYDwvJHtub2RlLnRhZ30+YDtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gZXZhbHVhdGVDb25zdGFudChleHApIHtcbiAgaWYgKGV4cC50eXBlID09PSA0KSB7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbihgcmV0dXJuICgke2V4cC5jb250ZW50fSlgKSgpO1xuICB9IGVsc2Uge1xuICAgIGxldCByZXMgPSBgYDtcbiAgICBleHAuY2hpbGRyZW4uZm9yRWFjaCgoYykgPT4ge1xuICAgICAgaWYgKHNoYXJlZC5pc1N0cmluZyhjKSB8fCBzaGFyZWQuaXNTeW1ib2woYykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGMudHlwZSA9PT0gMikge1xuICAgICAgICByZXMgKz0gYy5jb250ZW50O1xuICAgICAgfSBlbHNlIGlmIChjLnR5cGUgPT09IDUpIHtcbiAgICAgICAgcmVzICs9IHNoYXJlZC50b0Rpc3BsYXlTdHJpbmcoZXZhbHVhdGVDb25zdGFudChjLmNvbnRlbnQpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcyArPSBldmFsdWF0ZUNvbnN0YW50KGMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXM7XG4gIH1cbn1cblxuY29uc3QgaWdub3JlU2lkZUVmZmVjdFRhZ3MgPSAobm9kZSwgY29udGV4dCkgPT4ge1xuICBpZiAobm9kZS50eXBlID09PSAxICYmIG5vZGUudGFnVHlwZSA9PT0gMCAmJiAobm9kZS50YWcgPT09IFwic2NyaXB0XCIgfHwgbm9kZS50YWcgPT09IFwic3R5bGVcIikpIHtcbiAgICBjb250ZXh0Lm9uRXJyb3IoXG4gICAgICBjcmVhdGVET01Db21waWxlckVycm9yKFxuICAgICAgICA2MyxcbiAgICAgICAgbm9kZS5sb2NcbiAgICAgIClcbiAgICApO1xuICAgIGNvbnRleHQucmVtb3ZlTm9kZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBpc1ZhbGlkSFRNTE5lc3RpbmcocGFyZW50LCBjaGlsZCkge1xuICBpZiAocGFyZW50ID09PSBcInRlbXBsYXRlXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAocGFyZW50IGluIG9ubHlWYWxpZENoaWxkcmVuKSB7XG4gICAgcmV0dXJuIG9ubHlWYWxpZENoaWxkcmVuW3BhcmVudF0uaGFzKGNoaWxkKTtcbiAgfVxuICBpZiAoY2hpbGQgaW4gb25seVZhbGlkUGFyZW50cykge1xuICAgIHJldHVybiBvbmx5VmFsaWRQYXJlbnRzW2NoaWxkXS5oYXMocGFyZW50KTtcbiAgfVxuICBpZiAocGFyZW50IGluIGtub3duSW52YWxpZENoaWxkcmVuKSB7XG4gICAgaWYgKGtub3duSW52YWxpZENoaWxkcmVuW3BhcmVudF0uaGFzKGNoaWxkKSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChjaGlsZCBpbiBrbm93bkludmFsaWRQYXJlbnRzKSB7XG4gICAgaWYgKGtub3duSW52YWxpZFBhcmVudHNbY2hpbGRdLmhhcyhwYXJlbnQpKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5jb25zdCBoZWFkaW5ncyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcImgxXCIsIFwiaDJcIiwgXCJoM1wiLCBcImg0XCIsIFwiaDVcIiwgXCJoNlwiXSk7XG5jb25zdCBlbXB0eVNldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtdKTtcbmNvbnN0IG9ubHlWYWxpZENoaWxkcmVuID0ge1xuICBoZWFkOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gICAgXCJiYXNlXCIsXG4gICAgXCJiYXNlZnJvbnRcIixcbiAgICBcImJnc291bmRcIixcbiAgICBcImxpbmtcIixcbiAgICBcIm1ldGFcIixcbiAgICBcInRpdGxlXCIsXG4gICAgXCJub3NjcmlwdFwiLFxuICAgIFwibm9mcmFtZXNcIixcbiAgICBcInN0eWxlXCIsXG4gICAgXCJzY3JpcHRcIixcbiAgICBcInRlbXBsYXRlXCJcbiAgXSksXG4gIG9wdGdyb3VwOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJvcHRpb25cIl0pLFxuICBzZWxlY3Q6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcIm9wdGdyb3VwXCIsIFwib3B0aW9uXCIsIFwiaHJcIl0pLFxuICAvLyB0YWJsZVxuICB0YWJsZTogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiY2FwdGlvblwiLCBcImNvbGdyb3VwXCIsIFwidGJvZHlcIiwgXCJ0Zm9vdFwiLCBcInRoZWFkXCJdKSxcbiAgdHI6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcInRkXCIsIFwidGhcIl0pLFxuICBjb2xncm91cDogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiY29sXCJdKSxcbiAgdGJvZHk6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcInRyXCJdKSxcbiAgdGhlYWQ6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcInRyXCJdKSxcbiAgdGZvb3Q6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcInRyXCJdKSxcbiAgLy8gdGhlc2UgZWxlbWVudHMgY2FuIG5vdCBoYXZlIGFueSBjaGlsZHJlbiBlbGVtZW50c1xuICBzY3JpcHQ6IGVtcHR5U2V0LFxuICBpZnJhbWU6IGVtcHR5U2V0LFxuICBvcHRpb246IGVtcHR5U2V0LFxuICB0ZXh0YXJlYTogZW1wdHlTZXQsXG4gIHN0eWxlOiBlbXB0eVNldCxcbiAgdGl0bGU6IGVtcHR5U2V0XG59O1xuY29uc3Qgb25seVZhbGlkUGFyZW50cyA9IHtcbiAgLy8gc2VjdGlvbnNcbiAgaHRtbDogZW1wdHlTZXQsXG4gIGJvZHk6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcImh0bWxcIl0pLFxuICBoZWFkOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJodG1sXCJdKSxcbiAgLy8gdGFibGVcbiAgdGQ6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcInRyXCJdKSxcbiAgY29sZ3JvdXA6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcInRhYmxlXCJdKSxcbiAgY2FwdGlvbjogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1widGFibGVcIl0pLFxuICB0Ym9keTogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1widGFibGVcIl0pLFxuICB0Zm9vdDogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1widGFibGVcIl0pLFxuICBjb2w6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcImNvbGdyb3VwXCJdKSxcbiAgdGg6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcInRyXCJdKSxcbiAgdGhlYWQ6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcInRhYmxlXCJdKSxcbiAgdHI6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcInRib2R5XCIsIFwidGhlYWRcIiwgXCJ0Zm9vdFwiXSksXG4gIC8vIGRhdGEgbGlzdFxuICBkZDogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiZGxcIiwgXCJkaXZcIl0pLFxuICBkdDogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiZGxcIiwgXCJkaXZcIl0pLFxuICAvLyBvdGhlclxuICBmaWdjYXB0aW9uOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJmaWd1cmVcIl0pLFxuICAvLyBsaTogbmV3IFNldChbXCJ1bFwiLCBcIm9sXCJdKSxcbiAgc3VtbWFyeTogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiZGV0YWlsc1wiXSksXG4gIGFyZWE6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcIm1hcFwiXSlcbn07XG5jb25zdCBrbm93bkludmFsaWRDaGlsZHJlbiA9IHtcbiAgcDogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICAgIFwiYWRkcmVzc1wiLFxuICAgIFwiYXJ0aWNsZVwiLFxuICAgIFwiYXNpZGVcIixcbiAgICBcImJsb2NrcXVvdGVcIixcbiAgICBcImNlbnRlclwiLFxuICAgIFwiZGV0YWlsc1wiLFxuICAgIFwiZGlhbG9nXCIsXG4gICAgXCJkaXJcIixcbiAgICBcImRpdlwiLFxuICAgIFwiZGxcIixcbiAgICBcImZpZWxkc2V0XCIsXG4gICAgXCJmaWd1cmVcIixcbiAgICBcImZvb3RlclwiLFxuICAgIFwiZm9ybVwiLFxuICAgIFwiaDFcIixcbiAgICBcImgyXCIsXG4gICAgXCJoM1wiLFxuICAgIFwiaDRcIixcbiAgICBcImg1XCIsXG4gICAgXCJoNlwiLFxuICAgIFwiaGVhZGVyXCIsXG4gICAgXCJoZ3JvdXBcIixcbiAgICBcImhyXCIsXG4gICAgXCJsaVwiLFxuICAgIFwibWFpblwiLFxuICAgIFwibmF2XCIsXG4gICAgXCJtZW51XCIsXG4gICAgXCJvbFwiLFxuICAgIFwicFwiLFxuICAgIFwicHJlXCIsXG4gICAgXCJzZWN0aW9uXCIsXG4gICAgXCJ0YWJsZVwiLFxuICAgIFwidWxcIlxuICBdKSxcbiAgc3ZnOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gICAgXCJiXCIsXG4gICAgXCJibG9ja3F1b3RlXCIsXG4gICAgXCJiclwiLFxuICAgIFwiY29kZVwiLFxuICAgIFwiZGRcIixcbiAgICBcImRpdlwiLFxuICAgIFwiZGxcIixcbiAgICBcImR0XCIsXG4gICAgXCJlbVwiLFxuICAgIFwiZW1iZWRcIixcbiAgICBcImgxXCIsXG4gICAgXCJoMlwiLFxuICAgIFwiaDNcIixcbiAgICBcImg0XCIsXG4gICAgXCJoNVwiLFxuICAgIFwiaDZcIixcbiAgICBcImhyXCIsXG4gICAgXCJpXCIsXG4gICAgXCJpbWdcIixcbiAgICBcImxpXCIsXG4gICAgXCJtZW51XCIsXG4gICAgXCJtZXRhXCIsXG4gICAgXCJvbFwiLFxuICAgIFwicFwiLFxuICAgIFwicHJlXCIsXG4gICAgXCJydWJ5XCIsXG4gICAgXCJzXCIsXG4gICAgXCJzbWFsbFwiLFxuICAgIFwic3BhblwiLFxuICAgIFwic3Ryb25nXCIsXG4gICAgXCJzdWJcIixcbiAgICBcInN1cFwiLFxuICAgIFwidGFibGVcIixcbiAgICBcInVcIixcbiAgICBcInVsXCIsXG4gICAgXCJ2YXJcIlxuICBdKVxufTtcbmNvbnN0IGtub3duSW52YWxpZFBhcmVudHMgPSB7XG4gIGE6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcImFcIl0pLFxuICBidXR0b246IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcImJ1dHRvblwiXSksXG4gIGRkOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJkZFwiLCBcImR0XCJdKSxcbiAgZHQ6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcImRkXCIsIFwiZHRcIl0pLFxuICBmb3JtOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJmb3JtXCJdKSxcbiAgbGk6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcImxpXCJdKSxcbiAgaDE6IGhlYWRpbmdzLFxuICBoMjogaGVhZGluZ3MsXG4gIGgzOiBoZWFkaW5ncyxcbiAgaDQ6IGhlYWRpbmdzLFxuICBoNTogaGVhZGluZ3MsXG4gIGg2OiBoZWFkaW5nc1xufTtcblxuY29uc3QgdmFsaWRhdGVIdG1sTmVzdGluZyA9IChub2RlLCBjb250ZXh0KSA9PiB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEgJiYgbm9kZS50YWdUeXBlID09PSAwICYmIGNvbnRleHQucGFyZW50ICYmIGNvbnRleHQucGFyZW50LnR5cGUgPT09IDEgJiYgY29udGV4dC5wYXJlbnQudGFnVHlwZSA9PT0gMCAmJiAhaXNWYWxpZEhUTUxOZXN0aW5nKGNvbnRleHQucGFyZW50LnRhZywgbm9kZS50YWcpKSB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgU3ludGF4RXJyb3IoXG4gICAgICBgPCR7bm9kZS50YWd9PiBjYW5ub3QgYmUgY2hpbGQgb2YgPCR7Y29udGV4dC5wYXJlbnQudGFnfT4sIGFjY29yZGluZyB0byBIVE1MIHNwZWNpZmljYXRpb25zLiBUaGlzIGNhbiBjYXVzZSBoeWRyYXRpb24gZXJyb3JzIG9yIHBvdGVudGlhbGx5IGRpc3J1cHQgZnV0dXJlIGZ1bmN0aW9uYWxpdHkuYFxuICAgICk7XG4gICAgZXJyb3IubG9jID0gbm9kZS5sb2M7XG4gICAgY29udGV4dC5vbldhcm4oZXJyb3IpO1xuICB9XG59O1xuXG5jb25zdCBET01Ob2RlVHJhbnNmb3JtcyA9IFtcbiAgdHJhbnNmb3JtU3R5bGUsXG4gIC4uLlt0cmFuc2Zvcm1UcmFuc2l0aW9uLCB2YWxpZGF0ZUh0bWxOZXN0aW5nXSBcbl07XG5jb25zdCBET01EaXJlY3RpdmVUcmFuc2Zvcm1zID0ge1xuICBjbG9hazogY29tcGlsZXJDb3JlLm5vb3BEaXJlY3RpdmVUcmFuc2Zvcm0sXG4gIGh0bWw6IHRyYW5zZm9ybVZIdG1sLFxuICB0ZXh0OiB0cmFuc2Zvcm1WVGV4dCxcbiAgbW9kZWw6IHRyYW5zZm9ybU1vZGVsLFxuICAvLyBvdmVycmlkZSBjb21waWxlci1jb3JlXG4gIG9uOiB0cmFuc2Zvcm1PbixcbiAgLy8gb3ZlcnJpZGUgY29tcGlsZXItY29yZVxuICBzaG93OiB0cmFuc2Zvcm1TaG93XG59O1xuZnVuY3Rpb24gY29tcGlsZShzcmMsIG9wdGlvbnMgPSB7fSkge1xuICByZXR1cm4gY29tcGlsZXJDb3JlLmJhc2VDb21waWxlKFxuICAgIHNyYyxcbiAgICBzaGFyZWQuZXh0ZW5kKHt9LCBwYXJzZXJPcHRpb25zLCBvcHRpb25zLCB7XG4gICAgICBub2RlVHJhbnNmb3JtczogW1xuICAgICAgICAvLyBpZ25vcmUgPHNjcmlwdD4gYW5kIDx0YWc+XG4gICAgICAgIC8vIHRoaXMgaXMgbm90IHB1dCBpbnNpZGUgRE9NTm9kZVRyYW5zZm9ybXMgYmVjYXVzZSB0aGF0IGxpc3QgaXMgdXNlZFxuICAgICAgICAvLyBieSBjb21waWxlci1zc3IgdG8gZ2VuZXJhdGUgdm5vZGUgZmFsbGJhY2sgYnJhbmNoZXNcbiAgICAgICAgaWdub3JlU2lkZUVmZmVjdFRhZ3MsXG4gICAgICAgIC4uLkRPTU5vZGVUcmFuc2Zvcm1zLFxuICAgICAgICAuLi5vcHRpb25zLm5vZGVUcmFuc2Zvcm1zIHx8IFtdXG4gICAgICBdLFxuICAgICAgZGlyZWN0aXZlVHJhbnNmb3Jtczogc2hhcmVkLmV4dGVuZChcbiAgICAgICAge30sXG4gICAgICAgIERPTURpcmVjdGl2ZVRyYW5zZm9ybXMsXG4gICAgICAgIG9wdGlvbnMuZGlyZWN0aXZlVHJhbnNmb3JtcyB8fCB7fVxuICAgICAgKSxcbiAgICAgIHRyYW5zZm9ybUhvaXN0OiBzdHJpbmdpZnlTdGF0aWNcbiAgICB9KVxuICApO1xufVxuZnVuY3Rpb24gcGFyc2UodGVtcGxhdGUsIG9wdGlvbnMgPSB7fSkge1xuICByZXR1cm4gY29tcGlsZXJDb3JlLmJhc2VQYXJzZSh0ZW1wbGF0ZSwgc2hhcmVkLmV4dGVuZCh7fSwgcGFyc2VyT3B0aW9ucywgb3B0aW9ucykpO1xufVxuXG5leHBvcnRzLkRPTURpcmVjdGl2ZVRyYW5zZm9ybXMgPSBET01EaXJlY3RpdmVUcmFuc2Zvcm1zO1xuZXhwb3J0cy5ET01FcnJvckNvZGVzID0gRE9NRXJyb3JDb2RlcztcbmV4cG9ydHMuRE9NRXJyb3JNZXNzYWdlcyA9IERPTUVycm9yTWVzc2FnZXM7XG5leHBvcnRzLkRPTU5vZGVUcmFuc2Zvcm1zID0gRE9NTm9kZVRyYW5zZm9ybXM7XG5leHBvcnRzLlRSQU5TSVRJT04gPSBUUkFOU0lUSU9OO1xuZXhwb3J0cy5UUkFOU0lUSU9OX0dST1VQID0gVFJBTlNJVElPTl9HUk9VUDtcbmV4cG9ydHMuVl9NT0RFTF9DSEVDS0JPWCA9IFZfTU9ERUxfQ0hFQ0tCT1g7XG5leHBvcnRzLlZfTU9ERUxfRFlOQU1JQyA9IFZfTU9ERUxfRFlOQU1JQztcbmV4cG9ydHMuVl9NT0RFTF9SQURJTyA9IFZfTU9ERUxfUkFESU87XG5leHBvcnRzLlZfTU9ERUxfU0VMRUNUID0gVl9NT0RFTF9TRUxFQ1Q7XG5leHBvcnRzLlZfTU9ERUxfVEVYVCA9IFZfTU9ERUxfVEVYVDtcbmV4cG9ydHMuVl9PTl9XSVRIX0tFWVMgPSBWX09OX1dJVEhfS0VZUztcbmV4cG9ydHMuVl9PTl9XSVRIX01PRElGSUVSUyA9IFZfT05fV0lUSF9NT0RJRklFUlM7XG5leHBvcnRzLlZfU0hPVyA9IFZfU0hPVztcbmV4cG9ydHMuY29tcGlsZSA9IGNvbXBpbGU7XG5leHBvcnRzLmNyZWF0ZURPTUNvbXBpbGVyRXJyb3IgPSBjcmVhdGVET01Db21waWxlckVycm9yO1xuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuZXhwb3J0cy5wYXJzZXJPcHRpb25zID0gcGFyc2VyT3B0aW9ucztcbmV4cG9ydHMudHJhbnNmb3JtU3R5bGUgPSB0cmFuc2Zvcm1TdHlsZTtcbk9iamVjdC5rZXlzKGNvbXBpbGVyQ29yZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICBpZiAoayAhPT0gJ2RlZmF1bHQnICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgaykpIGV4cG9ydHNba10gPSBjb21waWxlckNvcmVba107XG59KTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@vue+compiler-dom@3.5.22/node_modules/@vue/compiler-dom/dist/compiler-dom.cjs.js\n");

/***/ })

};
;